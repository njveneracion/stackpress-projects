import fields from '../config/fields.js';
import formats from '../config/formats.js';
export default class Attributes extends Map {
    get active() {
        return this.get('active') === true;
    }
    get admin() {
        const attributes = {};
        for (const name of this.keys()) {
            if (!name.startsWith('admin.')) {
                continue;
            }
            const attribute = this.get(name);
            const method = name.replace('admin.', '');
            attributes[method] = attribute;
        }
        return new Attributes(Object.entries(attributes));
    }
    get assertions() {
        const assertions = [];
        for (const name of this.keys()) {
            if (!name.startsWith('is.')) {
                continue;
            }
            const field = this.get(name);
            const method = name.replace('is.', '');
            const args = Array.isArray(field) ? [...field] : [];
            const message = typeof args[args.length - 1] === 'string'
                ? args.pop()
                : null;
            assertions.push({ method, args, message });
        }
        return assertions;
    }
    get clen() {
        this.assertions.forEach(assertion => {
            if (assertion.method === 'ceq') {
                return assertion.args[0];
            }
            else if (assertion.method === 'clt') {
                return assertion.args[0];
            }
            else if (assertion.method === 'cle') {
                return assertion.args[0];
            }
        });
        return 255;
    }
    get created() {
        return this.get('created') === true;
    }
    get default() {
        const defaults = this.get('default');
        if (Array.isArray(defaults)) {
            return defaults[0];
        }
        return undefined;
    }
    get description() {
        const description = this.get('description');
        if (Array.isArray(description)) {
            return description[0];
        }
        return undefined;
    }
    get encrypted() {
        return this.get('encrypted') === true;
    }
    get example() {
        const example = this.get('example');
        if (Array.isArray(example)) {
            return example[0];
        }
        return undefined;
    }
    get field() {
        for (const name of this.keys()) {
            if (!name.startsWith('field.')) {
                continue;
            }
            const field = this.get(name);
            const method = name.replace('field.', '');
            const args = Array.isArray(field) ? field : [];
            const attributes = typeof args[0] === 'object'
                ? (args[0] || {})
                : {};
            const component = fields[method] || {
                component: false,
                attributes: {}
            };
            return {
                method,
                args,
                attributes: {
                    ...component.attributes,
                    ...attributes
                },
                component: component.name
            };
        }
        return {
            component: false,
            method: 'none',
            args: [],
            attributes: {}
        };
    }
    get filter() {
        for (const name of this.keys()) {
            if (!name.startsWith('filter.')) {
                continue;
            }
            const field = this.get(name);
            const method = name.replace('filter.', '');
            const args = Array.isArray(field) ? field : [];
            const attributes = typeof args[0] === 'object'
                ? (args[0] || {})
                : {};
            const component = fields[method] || {
                component: false,
                attributes: {}
            };
            return {
                method,
                args,
                attributes: {
                    ...component.attributes,
                    ...attributes
                },
                component: component.name
            };
        }
        return {
            component: false,
            method: 'none',
            args: [],
            attributes: {}
        };
    }
    get generated() {
        return this.get('generated') === true;
    }
    get hash() {
        return this.get('hash') === true;
    }
    get id() {
        return this.get('id') === true;
    }
    get icon() {
        const icon = this.get('icon');
        if (Array.isArray(icon)) {
            return icon[0];
        }
        return undefined;
    }
    get indexable() {
        return this.searchable
            || this.filter.method !== 'none'
            || this.span.method !== 'none'
            || this.sortable;
    }
    get label() {
        return this.labels[0] || undefined;
    }
    get labels() {
        const labels = this.get('label');
        return Array.isArray(labels) ? labels : [];
    }
    get list() {
        for (const name of this.keys()) {
            if (!name.startsWith('list.')) {
                continue;
            }
            const field = this.get(name);
            const method = name.replace('list.', '');
            const args = Array.isArray(field) ? field : [];
            const attributes = typeof args[0] === 'object'
                ? (args[0] || {})
                : {};
            const component = formats[method] || {
                component: false,
                attributes: {}
            };
            return {
                method,
                args,
                attributes: {
                    ...component.attributes,
                    ...attributes
                },
                component: component.name
            };
        }
        return {
            component: false,
            method: 'none',
            args: [],
            attributes: {}
        };
    }
    get max() {
        const maxes = [];
        const max = this.get('max');
        if (Array.isArray(max)) {
            maxes.push(max[0]);
        }
        this.assertions.forEach(assertion => {
            if (assertion.method === 'eq'
                || assertion.method === 'lt'
                || assertion.method === 'le') {
                maxes.push(assertion.args[0]);
            }
        });
        if (maxes.length > 0) {
            return Math.max(...maxes.filter(number => Number(number)));
        }
        return 0;
    }
    get min() {
        const mins = [];
        const min = this.get('min');
        if (Array.isArray(min)) {
            mins.push(min[0]);
        }
        this.assertions.forEach(assertion => {
            if (assertion.method === 'eq'
                || assertion.method === 'gt'
                || assertion.method === 'ge') {
                mins.push(assertion.args[0]);
            }
        });
        if (mins.length > 0) {
            return Math.min(...mins.filter(number => Number(number)));
        }
        return 0;
    }
    get query() {
        const query = this.get('query');
        if (Array.isArray(query)) {
            return query[0];
        }
        return ['*'];
    }
    get relation() {
        const attribute = this.get('relation');
        if (!attribute || typeof attribute[0] !== 'object') {
            return null;
        }
        return attribute[0];
    }
    get searchable() {
        return this.get('searchable') === true;
    }
    get sortable() {
        return this.get('sortable') === true;
    }
    get span() {
        for (const name of this.keys()) {
            if (!name.startsWith('span.')) {
                continue;
            }
            const field = this.get(name);
            const method = name.replace('span.', '');
            const args = Array.isArray(field) ? field : [];
            const attributes = typeof args[0] === 'object'
                ? (args[0] || {})
                : {};
            const component = fields[method] || {
                component: false,
                attributes: {}
            };
            return {
                method,
                args,
                attributes: {
                    ...component.attributes,
                    ...attributes
                },
                component: component.name
            };
        }
        return {
            component: false,
            method: 'none',
            args: [],
            attributes: {}
        };
    }
    get step() {
        const step = this.get('step');
        if (Array.isArray(step)) {
            return step[0];
        }
        const max = this.max;
        const min = this.min;
        const maxDecimals = max.toString().split('.')[1]?.length || 0;
        const minDecimals = min.toString().split('.')[1]?.length || 0;
        const decimalLength = Math.max(maxDecimals, minDecimals);
        if (decimalLength === 0) {
            return 1;
        }
        return Math.pow(10, -decimalLength);
    }
    get template() {
        const template = this.get('template');
        if (Array.isArray(template)) {
            return template[0];
        }
        return undefined;
    }
    get unique() {
        return this.get('unique') === true;
    }
    get updated() {
        return this.get('updated') === true;
    }
    get view() {
        for (const name of this.keys()) {
            if (!name.startsWith('view.')) {
                continue;
            }
            const field = this.get(name);
            const method = name.replace('view.', '');
            const args = Array.isArray(field) ? field : [];
            const attributes = typeof args[0] === 'object'
                ? (args[0] || {})
                : {};
            const component = formats[method] || {
                component: false,
                attributes: {}
            };
            return {
                method,
                args,
                attributes: {
                    ...component.attributes,
                    ...attributes
                },
                component: component.name
            };
        }
        return {
            component: false,
            method: 'none',
            args: [],
            attributes: {}
        };
    }
    get zindex() {
        const zindex = this.get('zindex');
        if (Array.isArray(zindex)) {
            return zindex[0];
        }
        return undefined;
    }
}
