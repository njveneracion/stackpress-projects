import Revisions from '../client/Revisions.js';
import { sequence } from '../sql/helpers.js';
import create from '../sql/schema.js';
export default async function push(server, database, cli) {
    const config = server.config('client') || {};
    if (!config.revisions) {
        return;
    }
    const queries = [];
    const revisions = new Revisions(config.revisions, server.loader);
    const from = await revisions.last(-1);
    const to = await revisions.last();
    cli?.verbose && cli.control.system('Updating database...');
    if (!from && to) {
        cli?.verbose && cli.control.system('  with DROP/CREATE ...');
        const models = Array.from(to.registry.model.values());
        const order = sequence(models);
        for (const model of order) {
            queries.push(database.dialect.drop(model.snake));
        }
        for (const model of order.reverse()) {
            const exists = models.find(map => map.name === model.name);
            if (exists) {
                const schema = create(exists);
                schema.engine = database;
                queries.push(...schema.query());
            }
        }
        if (queries.length) {
            await database.transaction(async (connection) => {
                for (const query of queries) {
                    cli?.verbose && cli.control.info(query.query);
                    await connection.query(query);
                }
            });
        }
    }
    else if (from && to) {
        cli?.verbose && cli.control.system('  with ALTER ...');
        const previous = Array.from(from.registry.model.values()).map(model => create(model));
        const current = Array.from(to.registry.model.values()).map(model => create(model));
        const queries = [];
        for (const schema of current) {
            const name = schema.build().table;
            const before = previous.find(from => from.build().table === name);
            if (!before) {
                schema.engine = database;
                queries.push(...schema.query());
                continue;
            }
            try {
                queries.push(...database.diff(before, schema).query());
            }
            catch (e) { }
        }
        for (const schema of previous) {
            const name = schema.build().table;
            const after = current.find(to => to.build().table === name);
            if (!after) {
                queries.push(database.dialect.drop(name));
                continue;
            }
        }
        if (queries.length) {
            await database.transaction(async (connection) => {
                for (const query of queries) {
                    cli?.verbose && cli.control.info(query.query);
                    await connection.query(query);
                }
            });
        }
    }
    cli?.verbose && cli.control.success('Database Updated.');
}
;
