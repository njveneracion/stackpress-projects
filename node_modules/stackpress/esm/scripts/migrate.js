import path from 'node:path';
import Revisions from '../client/Revisions.js';
import { sequence } from '../sql/helpers.js';
import create from '../sql/schema.js';
export default async function migrate(server, database) {
    const root = server.config.path('client.revisions');
    const { migrations } = server.config('database') || {};
    if (!migrations || !root) {
        return;
    }
    const revisions = new Revisions(root, server.loader);
    if (!await revisions.last()) {
        return;
    }
    const fs = server.loader.fs;
    const first = await revisions.first();
    if (first) {
        const queries = [];
        const models = Array.from(first.registry.model.values());
        const order = sequence(models);
        for (const model of order) {
            queries.push(database.dialect.drop(model.snake));
        }
        for (const model of order.reverse()) {
            const exists = models.find(map => map.name === model.name);
            if (exists) {
                const schema = create(exists);
                schema.engine = database;
                queries.push(...schema.query());
            }
        }
        if (queries.length) {
            if (!await fs.exists(migrations)) {
                await fs.mkdir(migrations, { recursive: true });
            }
            await fs.writeFile(path.join(migrations, `${first.date.getTime()}.sql`), queries.map(query => query.query).join(';\n'));
        }
    }
    for (let i = 1; i < revisions.size(); i++) {
        const from = await revisions.index(i - 1);
        const to = await revisions.index(i);
        if (!from || !to)
            break;
        const previous = Array.from(from.registry.model.values()).map(model => create(model));
        const current = Array.from(to.registry.model.values()).map(model => create(model));
        const queries = [];
        for (const schema of current) {
            const name = schema.build().table;
            const before = previous.find(from => from.build().table === name);
            if (!before) {
                schema.engine = database;
                queries.push(...schema.query());
                continue;
            }
            try {
                queries.push(...database.diff(before, schema).query());
            }
            catch (e) { }
        }
        for (const schema of previous) {
            const name = schema.build().table;
            const after = current.find(to => to.build().table === name);
            if (!after) {
                queries.push(database.dialect.drop(name));
                continue;
            }
        }
        if (queries.length) {
            if (!await fs.exists(migrations)) {
                await fs.mkdir(migrations, { recursive: true });
            }
            await fs.writeFile(path.join(migrations, `${to.date.getTime()}.sql`), queries.map(query => query.query).join(';\n'));
        }
    }
}
;
