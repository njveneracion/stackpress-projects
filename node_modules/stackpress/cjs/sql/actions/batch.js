"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = batch;
const Exception_js_1 = __importDefault(require("../../Exception.js"));
const helpers_js_1 = require("../helpers.js");
const create_js_1 = __importDefault(require("./create.js"));
const update_js_1 = __importDefault(require("./update.js"));
function batch(model, engine, rows, seed) {
    return __awaiter(this, void 0, void 0, function* () {
        const actions = rows.map(row => {
            const action = model.ids.some(column => row[column.name] === undefined) ? 'create' : 'check';
            return { row, action };
        });
        const check = actions.filter(({ action }) => action === 'check');
        const q = engine.dialect.q;
        const ids = model.ids.map(column => column.name);
        const columns = model.ids.map(column => `${q}${column.snake}${q}`);
        const clauses = columns.map(column => `${column} = ?`).join(' AND ');
        const where = check.map(() => `(${clauses})`).join(' OR ');
        const values = check.map(({ row }) => {
            return ids.map(id => row[id]);
        }).flat();
        const results = [];
        try {
            let error = false;
            yield engine.transaction(() => __awaiter(this, void 0, void 0, function* () {
                if (where.length > 0 && values.length > 0) {
                    const exists = yield engine
                        .select(columns)
                        .from(model.snake)
                        .where(where, values);
                    for (const action of actions) {
                        if (action.action !== 'check')
                            continue;
                        action.action = exists.some(exist => ids.every(id => exist[id] === action.row[id])) ? 'update' : 'create';
                    }
                }
                for (const { row, action } of actions) {
                    if (action === 'create') {
                        const response = yield (0, create_js_1.default)(model, engine, row, seed);
                        if (response.code !== 200)
                            error = true;
                        results.push(response);
                    }
                    else if (action === 'update') {
                        const filter = Object.fromEntries(ids.map(id => [id, row[id]]));
                        const response = yield (0, update_js_1.default)(model, engine, filter, row, seed);
                        if (response.code !== 200)
                            error = true;
                        results.push(response);
                    }
                }
                if (error) {
                    throw Exception_js_1.default.for('Errors found in batch inputs');
                }
            }));
        }
        catch (e) {
            const error = Exception_js_1.default.upgrade(e);
            return {
                code: 400,
                status: 'Bad Request',
                error: error.message,
                results: results,
                total: results.length,
                stack: error.trace()
            };
        }
        return (0, helpers_js_1.toResponse)(results);
    });
}
;
