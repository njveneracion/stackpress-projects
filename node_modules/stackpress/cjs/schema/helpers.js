"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generators = void 0;
exports.camelize = camelize;
exports.capitalize = capitalize;
exports.dasherize = dasherize;
exports.decrypt = decrypt;
exports.encrypt = encrypt;
exports.hash = hash;
exports.lowerize = lowerize;
exports.snakerize = snakerize;
exports.render = render;
exports.objectToAttributeString = objectToAttributeString;
const node_crypto_1 = __importDefault(require("node:crypto"));
const mustache_1 = __importDefault(require("mustache"));
exports.generators = [
    'cuid()',
    'nano()',
    'random()',
    'now()'
];
function camelize(string) {
    return lowerize(string.trim()
        .replace(/[^a-zA-Z0-9]/g, '_')
        .replace(/_{2,}/g, '_')
        .replace(/^_+|_+$/g, '')
        .replace(/([-_][a-z0-9])/ig, ($1) => {
        return $1.toUpperCase()
            .replace('-', '')
            .replace('_', '');
    }));
}
function capitalize(word) {
    return word.charAt(0).toUpperCase() + word.slice(1);
}
function dasherize(string) {
    return string.trim()
        .replace(/[^a-zA-Z0-9]/g, '-')
        .replace(/-{2,}/g, '-')
        .replace(/^-+|-+$/g, '')
        .replace(/([a-z])([A-Z0-9])/g, '$1-$2')
        .toLowerCase();
}
function decrypt(encrypted, seed) {
    const value = Buffer.from(encrypted, 'hex');
    const hash = node_crypto_1.default
        .createHash('sha256')
        .update(seed)
        .digest('base64')
        .substring(0, 32);
    const iv = hash.substring(0, 16);
    const decipher = node_crypto_1.default.createDecipheriv('aes-256-cbc', hash, iv);
    return Buffer.concat([
        decipher.update(value),
        decipher.final()
    ]).toString();
}
function encrypt(value, seed) {
    const hash = node_crypto_1.default
        .createHash('sha256')
        .update(seed)
        .digest('base64')
        .substring(0, 32);
    const iv = hash.substring(0, 16);
    const cipher = node_crypto_1.default.createCipheriv('aes-256-cbc', hash, iv);
    const encrypted = Buffer.concat([
        cipher.update(value),
        cipher.final()
    ]);
    return encrypted.toString('hex');
}
function hash(string) {
    return node_crypto_1.default
        .createHash('shake256')
        .update(string)
        .digest('hex');
}
function lowerize(word) {
    return word.charAt(0).toLowerCase() + word.slice(1);
}
function snakerize(string) {
    return string.trim()
        .replace(/[^a-zA-Z0-9]/g, '_')
        .replace(/-{2,}/g, '_')
        .replace(/^_+|_+$/g, '')
        .replace(/([a-z])([A-Z0-9])/g, '$1_$2')
        .toLowerCase();
}
function render(template, data = {}) {
    return mustache_1.default.render(template, data);
}
function objectToAttributeString(attributes) {
    return Object.entries(attributes).map(([key, value]) => {
        return `${key}={${JSON.stringify(value)}}`;
    }).join(' ');
}
