"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signup = signup;
exports.signin = signin;
exports.assert = assert;
const assert_js_1 = require("../schema/assert.js");
const helpers_js_1 = require("../schema/helpers.js");
function signup(input, seed, engine, client) {
    return __awaiter(this, void 0, void 0, function* () {
        const errors = assert(input);
        if (errors) {
            return { code: 400, error: 'Invalid Parameters', errors };
        }
        const profile = client.model.profile;
        const response = yield profile.actions(engine, seed).create({
            name: input.name,
            type: input.type || 'person',
            roles: input.roles || []
        });
        if (response.code !== 200) {
            return response;
        }
        const results = response.results;
        results.auth = {};
        const actions = client.model.auth.actions(engine, seed);
        if (input.email) {
            const auth = yield actions.create({
                profileId: results.id,
                type: 'email',
                token: String(input.email),
                secret: String(input.secret)
            });
            if (auth.code !== 200) {
                return auth;
            }
            results.auth.email = auth.results;
        }
        if (input.phone) {
            const auth = yield actions.create({
                profileId: results.id,
                type: 'phone',
                token: String(input.phone),
                secret: String(input.secret)
            });
            if (auth.code !== 200) {
                return auth;
            }
            results.auth.phone = auth.results;
        }
        if (input.username) {
            const auth = yield actions.create({
                profileId: results.id,
                type: 'username',
                token: String(input.username),
                secret: String(input.secret)
            });
            if (auth.code !== 200) {
                return auth;
            }
            results.auth.username = auth.results;
        }
        return Object.assign(Object.assign({}, response), { results });
    });
}
;
function signin(type_1, input_1, seed_1, engine_1, client_1) {
    return __awaiter(this, arguments, void 0, function* (type, input, seed, engine, client, password = true) {
        var _a;
        const actions = client.model.auth.actions(engine);
        const token = (0, helpers_js_1.encrypt)(String(input[type]), seed);
        const response = yield actions.search({
            columns: ['*', 'profile.*'],
            filter: { type, token }
        });
        const results = (_a = response.results) === null || _a === void 0 ? void 0 : _a[0];
        if (response.code !== 200) {
            return Object.assign(Object.assign({}, response), { results });
        }
        else if (!results) {
            return {
                code: 404,
                status: 'Not Found',
                error: 'User Not Found'
            };
        }
        else if (password) {
            const secret = (0, helpers_js_1.hash)(String(input.secret));
            if (secret !== String(results.secret)) {
                return {
                    code: 401,
                    status: 'Unauthorized',
                    error: 'Invalid Password'
                };
            }
        }
        yield actions.update({ id: results.id }, {
            consumed: new Date()
        });
        return {
            code: 200,
            status: 'OK',
            results: results,
            total: 1
        };
    });
}
;
function assert(input) {
    const errors = {};
    if (!input.name) {
        errors.name = 'Name is required';
    }
    if (!input.username && !input.email && !input.phone) {
        errors.type = 'Username, email, or phone is required';
    }
    else if (input.email && !(0, assert_js_1.email)(input.email)) {
        errors.email = 'Invalid email';
    }
    if (!input.secret) {
        errors.secret = 'Password is required';
    }
    return Object.keys(errors).length ? errors : null;
}
;
