"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = generate;
exports.generateModel = generateModel;
exports.generateFieldset = generateFieldset;
const typemap = __importStar(require("../../schema/config/typemaps.js"));
function generate(directory, registry) {
    for (const model of registry.model.values()) {
        const file = `${model.name}/types.ts`;
        const source = directory.createSourceFile(file, '', { overwrite: true });
        generateModel(source, model);
    }
    for (const fieldset of registry.fieldset.values()) {
        const file = `${fieldset.name}/types.ts`;
        const source = directory.createSourceFile(file, '', { overwrite: true });
        generateFieldset(source, fieldset);
    }
    const source = directory.createSourceFile('types.ts', '', { overwrite: true });
    for (const model of registry.model.values()) {
        source.addExportDeclaration({
            isTypeOnly: true,
            moduleSpecifier: `./${model.name}/types.js`,
            namedExports: [model.title, `${model.title}Input`, `${model.title}Extended`]
        });
    }
    for (const fieldset of registry.fieldset.values()) {
        source.addExportDeclaration({
            isTypeOnly: true,
            moduleSpecifier: `./${fieldset.name}/types.js`,
            namedExports: [fieldset.title, `${fieldset.title}Input`]
        });
    }
}
;
function generateModel(source, model) {
    const columns = Array.from(model.columns.values());
    const enums = Array.from(model.enums.values()).map(column => column.type);
    if (enums.length > 0) {
        source.addImportDeclaration({
            moduleSpecifier: '../enums.js',
            namedImports: enums
        });
    }
    for (const column of model.relations) {
        const relation = column.relation;
        if (!relation)
            continue;
        const model = relation === null || relation === void 0 ? void 0 : relation.parent.model;
        source.addImportDeclaration({
            moduleSpecifier: `../${model.name}/types.js`,
            namedImports: [model.title]
        });
    }
    for (const column of model.fieldsets.values()) {
        source.addImportDeclaration({
            moduleSpecifier: `../${column.type}/types.js`,
            namedImports: [column.type]
        });
    }
    source.addTypeAlias({
        isExported: true,
        name: model.title,
        type: (`{
      ${columns.filter(column => !!column.typemap.model || !!column.enum || !!column.fieldset).map(column => (`${column.name}${!column.required ? '?' : ''}: ${column.typemap.model || column.type}${column.multiple ? '[]' : ''}`)).join(',\n')}
    }`)
    });
    if (model.relations.length) {
        source.addTypeAlias({
            isExported: true,
            name: `${model.title}Extended`,
            type: (`${model.title} & {
        ${model.relations.map(column => (`${column.name}${!column.required ? '?' : ''}: ${column.type}${column.multiple ? '[]' : ''}`)).join(',\n')}
      }`)
        });
    }
    else {
        source.addTypeAlias({
            isExported: true,
            name: `${model.title}Extended`,
            type: model.title
        });
    }
    const inputs = columns
        .filter(column => !column.generated)
        .filter(column => [
        ...Object.keys(typemap.model),
        ...model.enums.map(column => column.type),
        ...model.fieldsets.map(column => { var _a; return (_a = column.fieldset) === null || _a === void 0 ? void 0 : _a.title; })
    ].includes(column.type));
    source.addTypeAlias({
        isExported: true,
        name: `${model.title}Input`,
        type: (`{
      ${inputs.map(column => (`${column.name}${!column.required || typeof column.default !== 'undefined' ? '?' : ''}: ${column.typemap.model || column.type}${column.multiple ? '[]' : ''}`)).join(',\n')}
    }`)
    });
}
;
function generateFieldset(source, fieldset) {
    const columns = Array.from(fieldset.columns.values());
    const enums = Array.from(fieldset.enums.values()).map(column => column.type);
    if (enums.length > 0) {
        source.addImportDeclaration({
            moduleSpecifier: '../enums.js',
            namedImports: enums
        });
    }
    for (const column of fieldset.fieldsets.values()) {
        source.addImportDeclaration({
            moduleSpecifier: `../${column.type}/types.js`,
            namedImports: [column.type]
        });
    }
    source.addTypeAlias({
        isExported: true,
        name: fieldset.title,
        type: (`{
      ${columns.filter(column => !!column.typemap.model || !!column.enum || !!column.fieldset).map(column => (`${column.name}${!column.required ? '?' : ''}: ${column.typemap.model || column.type}${column.multiple ? '[]' : ''}`)).join(',\n')}
    }`)
    });
    const inputs = columns
        .filter(column => !column.generated)
        .filter(column => [
        ...Object.keys(typemap.model),
        ...fieldset.enums.map(column => column.type),
        ...fieldset.fieldsets.map(column => { var _a; return (_a = column.fieldset) === null || _a === void 0 ? void 0 : _a.title; })
    ].includes(column.type));
    source.addTypeAlias({
        isExported: true,
        name: `${fieldset.title}Input`,
        type: (`{
      ${inputs.map(column => (`${column.name}${!column.required || typeof column.default !== 'undefined' ? '?' : ''}: ${column.typemap.model || column.type}${column.multiple ? '[]' : ''}`)).join(',\n')}
    }`)
    });
}
;
