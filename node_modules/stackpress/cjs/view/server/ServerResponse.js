"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Status_1 = __importDefault(require("@stackpress/lib/Status"));
const Exception_1 = __importDefault(require("@stackpress/lib/Exception"));
const Nest_1 = require("@stackpress/lib/Nest");
class Response {
    get code() {
        return this._code;
    }
    get error() {
        return this._error;
    }
    get results() {
        if ((0, Nest_1.isObject)(this._results)) {
            return Object.freeze(this._results);
        }
        else if (Array.isArray(this._results)) {
            return Array.from(this._results);
        }
        return this._results;
    }
    get stack() {
        return this._stack;
    }
    get status() {
        return this._status;
    }
    get total() {
        return this._total;
    }
    constructor(response) {
        var _a;
        this._code = 0;
        this._status = '';
        this._total = 0;
        const { code, status, error, errors, stack, results, total } = response;
        if (code) {
            this._code = code;
        }
        if (status) {
            this._status = status;
        }
        else if (this._code) {
            this._status = ((_a = Status_1.default.get(this._code)) === null || _a === void 0 ? void 0 : _a.status) || 'Unknown Status';
        }
        if (error) {
            this._error = error;
        }
        this.errors = (0, Nest_1.nest)();
        if (errors) {
            this.errors.set(errors);
        }
        if (stack) {
            this._stack = stack;
        }
        if (results) {
            this._results = results;
        }
        if (total) {
            this._total = total;
        }
    }
    toException(message) {
        const error = message || this._error || 'Unknown Error';
        const exception = Exception_1.default.for(error)
            .withCode(this._code)
            .withErrors(this.errors());
        if (this._stack) {
            let stack = `Response: ${error}\n`;
            stack += this._stack.map(trace => `  at ${trace.method} (`
                + `${trace.file}:${trace.line}:${trace.char}`
                + `)`).join('\n');
            exception.stack = stack;
        }
        return exception;
    }
    toStatusResponse() {
        return {
            code: this._code,
            status: this._status,
            error: this._error,
            errors: this.errors(),
            stack: this._stack,
            results: this.results,
            total: this._total
        };
    }
}
exports.default = Response;
