"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = migrate;
const node_path_1 = __importDefault(require("node:path"));
const Revisions_js_1 = __importDefault(require("../client/Revisions.js"));
const helpers_js_1 = require("../sql/helpers.js");
const schema_js_1 = __importDefault(require("../sql/schema.js"));
function migrate(server, database) {
    return __awaiter(this, void 0, void 0, function* () {
        const root = server.config.path('client.revisions');
        const { migrations } = server.config('database') || {};
        if (!migrations || !root) {
            return;
        }
        const revisions = new Revisions_js_1.default(root, server.loader);
        if (!(yield revisions.last())) {
            return;
        }
        const fs = server.loader.fs;
        const first = yield revisions.first();
        if (first) {
            const queries = [];
            const models = Array.from(first.registry.model.values());
            const order = (0, helpers_js_1.sequence)(models);
            for (const model of order) {
                queries.push(database.dialect.drop(model.snake));
            }
            for (const model of order.reverse()) {
                const exists = models.find(map => map.name === model.name);
                if (exists) {
                    const schema = (0, schema_js_1.default)(exists);
                    schema.engine = database;
                    queries.push(...schema.query());
                }
            }
            if (queries.length) {
                if (!(yield fs.exists(migrations))) {
                    yield fs.mkdir(migrations, { recursive: true });
                }
                yield fs.writeFile(node_path_1.default.join(migrations, `${first.date.getTime()}.sql`), queries.map(query => query.query).join(';\n'));
            }
        }
        for (let i = 1; i < revisions.size(); i++) {
            const from = yield revisions.index(i - 1);
            const to = yield revisions.index(i);
            if (!from || !to)
                break;
            const previous = Array.from(from.registry.model.values()).map(model => (0, schema_js_1.default)(model));
            const current = Array.from(to.registry.model.values()).map(model => (0, schema_js_1.default)(model));
            const queries = [];
            for (const schema of current) {
                const name = schema.build().table;
                const before = previous.find(from => from.build().table === name);
                if (!before) {
                    schema.engine = database;
                    queries.push(...schema.query());
                    continue;
                }
                try {
                    queries.push(...database.diff(before, schema).query());
                }
                catch (e) { }
            }
            for (const schema of previous) {
                const name = schema.build().table;
                const after = current.find(to => to.build().table === name);
                if (!after) {
                    queries.push(database.dialect.drop(name));
                    continue;
                }
            }
            if (queries.length) {
                if (!(yield fs.exists(migrations))) {
                    yield fs.mkdir(migrations, { recursive: true });
                }
                yield fs.writeFile(node_path_1.default.join(migrations, `${to.date.getTime()}.sql`), queries.map(query => query.query).join(';\n'));
            }
        }
    });
}
;
