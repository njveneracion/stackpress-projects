"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Exception_js_1 = __importDefault(require("../Exception.js"));
const AbstractTree_js_1 = __importDefault(require("./AbstractTree.js"));
const EnumTree_js_1 = __importDefault(require("./EnumTree.js"));
const PropTree_js_1 = __importDefault(require("./PropTree.js"));
const TypeTree_js_1 = __importDefault(require("./TypeTree.js"));
const ModelTree_js_1 = __importDefault(require("./ModelTree.js"));
const PluginTree_js_1 = __importDefault(require("./PluginTree.js"));
const UseTree_js_1 = __importDefault(require("./UseTree.js"));
class SchemaTree extends AbstractTree_js_1.default {
    static definitions(lexer) {
        EnumTree_js_1.default.definitions(lexer);
        PropTree_js_1.default.definitions(lexer);
        TypeTree_js_1.default.definitions(lexer);
        ModelTree_js_1.default.definitions(lexer);
        PluginTree_js_1.default.definitions(lexer);
        UseTree_js_1.default.definitions(lexer);
        return lexer;
    }
    static parse(code) {
        return new this().parse(code);
    }
    constructor(lexer) {
        super(lexer);
        this._enumTree = new EnumTree_js_1.default(this._lexer);
        this._propTree = new PropTree_js_1.default(this._lexer);
        this._typeTree = new TypeTree_js_1.default(this._lexer);
        this._modelTree = new ModelTree_js_1.default(this._lexer);
        this._pluginTree = new PluginTree_js_1.default(this._lexer);
        this._useTree = new UseTree_js_1.default(this._lexer);
    }
    parse(code, start = 0) {
        this._lexer.load(code, start);
        this.noncode();
        const body = [];
        for (const token of this.dotryall(() => this._enumTree.enum(), () => this._propTree.prop(), () => this._typeTree.type(), () => this._modelTree.model(), () => this._pluginTree.plugin(), () => this._useTree.use())) {
            body.push(token);
            this.noncode();
        }
        if (this._lexer.index < code.length) {
            const remainder = code.substring(this._lexer.index, this._lexer.nextSpace()).trim();
            if (remainder.length) {
                throw Exception_js_1.default
                    .for(`Unexpected token %s`, remainder.replace(/[\n\r]/g, ' ').trim())
                    .withPosition(this._lexer.index, this._lexer.nextSpace());
            }
        }
        return {
            type: 'Program',
            kind: 'schema',
            start: 0,
            end: this._lexer.index,
            body
        };
    }
    *dotryall(...all) {
        let token;
        do {
            token = undefined;
            for (const callback of all) {
                try {
                    token = callback();
                    if (token) {
                        yield token;
                        break;
                    }
                }
                catch (error) { }
            }
        } while (token);
    }
}
exports.default = SchemaTree;
;
