import path from 'node:path';
import { parse, Exception } from '@stackpress/idea-parser';
import FileLoader from '@stackpress/lib/FileLoader';
import NodeFS from '@stackpress/lib/NodeFS';
export default class Transformer {
    static async load(input, options = {}) {
        const loader = new FileLoader(options.fs || new NodeFS(), options.cwd);
        input = await loader.absolute(input);
        return new Transformer(input, loader);
    }
    loader;
    input;
    _schema;
    constructor(input, loader) {
        this.input = input;
        this.loader = loader;
    }
    async schema() {
        if (!this._schema) {
            if (!(await this.loader.fs.exists(this.input))) {
                throw Exception.for('Input file %s does not exist', this.input);
            }
            const content = await this.loader.fs.readFile(this.input, 'utf8');
            const schema = path.extname(this.input) === '.json'
                ? JSON.parse(content)
                : parse(content);
            if (Array.isArray(schema.use)) {
                for (const file of schema.use) {
                    const absolute = await this.loader.resolveFile(file, ['.js'], this.loader.cwd, true);
                    const dirname = path.dirname(absolute);
                    const transformer = await Transformer.load(absolute, {
                        cwd: dirname,
                        fs: this.loader.fs
                    });
                    const child = await transformer.schema();
                    if (child.prop) {
                        schema.prop = { ...child.prop, ...schema.prop };
                    }
                    if (child.enum) {
                        schema.enum = { ...child.enum, ...schema.enum };
                    }
                    if (child.type) {
                        schema.type = schema.type || {};
                        for (const [name, type] of Object.entries(child.type)) {
                            const parent = schema.type[name];
                            if (!parent || !parent.mutable) {
                                schema.type[name] = type;
                                continue;
                            }
                            if (parent.mutable) {
                                this._merge(parent, type);
                            }
                        }
                    }
                    if (child.model) {
                        schema.model = schema.model || {};
                        for (const [name, model] of Object.entries(child.model)) {
                            const parent = schema.model[name];
                            if (!parent || !parent.mutable) {
                                schema.model[name] = model;
                                continue;
                            }
                            if (parent.mutable) {
                                this._merge(parent, model);
                            }
                        }
                    }
                }
            }
            delete schema.use;
            this._schema = schema;
        }
        return this._schema;
    }
    async transform(extras) {
        const schema = await this.schema();
        if (!schema.plugin || typeof schema.plugin !== 'object') {
            throw Exception.for('No plugins defined in schema file');
        }
        for (const plugin in schema.plugin) {
            const module = await this.loader.resolveFile(plugin, ['.js', '.cjs', '.mjs', '.ts', '.mts'], this.loader.cwd, true);
            const config = schema.plugin[plugin];
            const callback = await this.loader.import(module, true);
            if (typeof callback === 'function') {
                await callback({
                    ...extras,
                    transformer: this,
                    config,
                    schema,
                    cwd: this.loader.cwd
                });
            }
        }
    }
    _merge(parent, child) {
        if (child.attributes) {
            if (!parent.attributes) {
                parent.attributes = child.attributes;
            }
            else {
                parent.attributes = {
                    ...child.attributes,
                    ...parent.attributes
                };
            }
        }
        const parentColumns = parent.columns || [];
        const childColumns = child.columns || [];
        childColumns.reverse().forEach(childColumn => {
            const parentColumn = parentColumns.find(parentColumn => parentColumn.name === childColumn.name);
            if (!parentColumn) {
                if (!Array.isArray(parent.columns)) {
                    parent.columns = [];
                }
                parent.columns.unshift(childColumn);
            }
        });
    }
}
