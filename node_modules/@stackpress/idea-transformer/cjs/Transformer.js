"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_path_1 = __importDefault(require("node:path"));
const idea_parser_1 = require("@stackpress/idea-parser");
const FileLoader_1 = __importDefault(require("@stackpress/lib/FileLoader"));
const NodeFS_1 = __importDefault(require("@stackpress/lib/NodeFS"));
class Transformer {
    static load(input_1) {
        return __awaiter(this, arguments, void 0, function* (input, options = {}) {
            const loader = new FileLoader_1.default(options.fs || new NodeFS_1.default(), options.cwd);
            input = yield loader.absolute(input);
            return new Transformer(input, loader);
        });
    }
    constructor(input, loader) {
        this.input = input;
        this.loader = loader;
    }
    schema() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._schema) {
                if (!(yield this.loader.fs.exists(this.input))) {
                    throw idea_parser_1.Exception.for('Input file %s does not exist', this.input);
                }
                const content = yield this.loader.fs.readFile(this.input, 'utf8');
                const schema = node_path_1.default.extname(this.input) === '.json'
                    ? JSON.parse(content)
                    : (0, idea_parser_1.parse)(content);
                if (Array.isArray(schema.use)) {
                    for (const file of schema.use) {
                        const absolute = yield this.loader.resolveFile(file, ['.js'], this.loader.cwd, true);
                        const dirname = node_path_1.default.dirname(absolute);
                        const transformer = yield Transformer.load(absolute, {
                            cwd: dirname,
                            fs: this.loader.fs
                        });
                        const child = yield transformer.schema();
                        if (child.prop) {
                            schema.prop = Object.assign(Object.assign({}, child.prop), schema.prop);
                        }
                        if (child.enum) {
                            schema.enum = Object.assign(Object.assign({}, child.enum), schema.enum);
                        }
                        if (child.type) {
                            schema.type = schema.type || {};
                            for (const [name, type] of Object.entries(child.type)) {
                                const parent = schema.type[name];
                                if (!parent || !parent.mutable) {
                                    schema.type[name] = type;
                                    continue;
                                }
                                if (parent.mutable) {
                                    this._merge(parent, type);
                                }
                            }
                        }
                        if (child.model) {
                            schema.model = schema.model || {};
                            for (const [name, model] of Object.entries(child.model)) {
                                const parent = schema.model[name];
                                if (!parent || !parent.mutable) {
                                    schema.model[name] = model;
                                    continue;
                                }
                                if (parent.mutable) {
                                    this._merge(parent, model);
                                }
                            }
                        }
                    }
                }
                delete schema.use;
                this._schema = schema;
            }
            return this._schema;
        });
    }
    transform(extras) {
        return __awaiter(this, void 0, void 0, function* () {
            const schema = yield this.schema();
            if (!schema.plugin || typeof schema.plugin !== 'object') {
                throw idea_parser_1.Exception.for('No plugins defined in schema file');
            }
            for (const plugin in schema.plugin) {
                const module = yield this.loader.resolveFile(plugin, ['.js', '.cjs', '.mjs', '.ts', '.mts'], this.loader.cwd, true);
                const config = schema.plugin[plugin];
                const callback = yield this.loader.import(module, true);
                if (typeof callback === 'function') {
                    yield callback(Object.assign(Object.assign({}, extras), { transformer: this, config,
                        schema, cwd: this.loader.cwd }));
                }
            }
        });
    }
    _merge(parent, child) {
        if (child.attributes) {
            if (!parent.attributes) {
                parent.attributes = child.attributes;
            }
            else {
                parent.attributes = Object.assign(Object.assign({}, child.attributes), parent.attributes);
            }
        }
        const parentColumns = parent.columns || [];
        const childColumns = child.columns || [];
        childColumns.reverse().forEach(childColumn => {
            const parentColumn = parentColumns.find(parentColumn => parentColumn.name === childColumn.name);
            if (!parentColumn) {
                if (!Array.isArray(parent.columns)) {
                    parent.columns = [];
                }
                parent.columns.unshift(childColumn);
            }
        });
    }
}
exports.default = Transformer;
