"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.typemap = exports.q = void 0;
exports.getType = getType;
const Exception_js_1 = __importDefault(require("../Exception.js"));
const helpers_js_1 = require("../helpers.js");
exports.q = '`';
exports.typemap = {
    object: 'JSON',
    hash: 'JSON',
    json: 'JSON',
    char: 'CHAR',
    string: 'VARCHAR',
    varchar: 'VARCHAR',
    text: 'TEXT',
    bool: 'BOOLEAN',
    boolean: 'BOOLEAN',
    number: 'INT',
    int: 'INT',
    integer: 'INT',
    float: 'FLOAT',
    date: 'DATE',
    datetime: 'DATETIME',
    time: 'TIME'
};
function getType(key, length) {
    let type = exports.typemap[key.toLowerCase()] || key.toUpperCase();
    if (!Array.isArray(length)) {
        if (type === 'CHAR' || type === 'VARCHAR') {
            length = length || 255;
        }
        else if (type === 'INT' || type === 'FLOAT') {
            length = length || 11;
        }
        if (type === 'INT') {
            if (length === 1) {
                type = 'TINYINT';
                length = undefined;
            }
            else if (length && length > 11) {
                type = 'BIGINT';
                length = undefined;
            }
        }
    }
    return { type, length };
}
;
const Mysql = {
    q: exports.q,
    alter(builder) {
        const build = builder.build();
        const query = [];
        const removeFields = build.fields.remove.map(name => `DROP ${exports.q}${name}${exports.q}`);
        const addFields = Object.keys(build.fields.add).map(name => {
            const field = build.fields.add[name];
            const column = [];
            const { type, length } = getType(field.type, field.length);
            column.push(`${exports.q}${name}${exports.q}`);
            if (Array.isArray(length)) {
                column.push(`${type}(${length.join(', ')})`);
            }
            else if (length) {
                column.push(`${type}(${length})`);
            }
            else {
                column.push(type);
            }
            field.attribute && column.push(field.attribute);
            field.unsigned && column.push('UNSIGNED');
            field.nullable && column.push('NOT NULL');
            field.autoIncrement && column.push('AUTO_INCREMENT');
            if (field.default) {
                if (typeof field.default === 'boolean') {
                    column.push(`DEFAULT ${field.default ? 'TRUE' : 'FALSE'}`);
                }
                else if (!isNaN(Number(field.default))) {
                    column.push(`DEFAULT ${field.default}`);
                }
                else if (typeof field.default === 'string'
                    && field.default.endsWith('()')) {
                    column.push(`DEFAULT ${field.default.toUpperCase()}`);
                }
                else {
                    column.push(`DEFAULT '${field.default}'`);
                }
            }
            else if (field.nullable) {
                column.push('DEFAULT NULL');
            }
            return `ADD COLUMN ${column.join(' ')}`;
        });
        const changeFields = Object.keys(build.fields.update).map(name => {
            const field = build.fields.update[name];
            const column = [];
            const { type, length } = getType(field.type, field.length);
            column.push(`${exports.q}${name}${exports.q}`);
            if (Array.isArray(length)) {
                column.push(`${type}(${length.join(', ')})`);
            }
            else if (length) {
                column.push(`${type}(${length})`);
            }
            else {
                column.push(type);
            }
            field.attribute && column.push(field.attribute);
            field.unsigned && column.push('UNSIGNED');
            field.nullable && column.push('NOT NULL');
            field.autoIncrement && column.push('AUTO_INCREMENT');
            if (field.default) {
                if (!isNaN(Number(field.default))) {
                    column.push(`DEFAULT ${field.default}`);
                }
                else {
                    column.push(`DEFAULT '${field.default}'`);
                }
            }
            else if (field.nullable) {
                column.push('DEFAULT NULL');
            }
            return `CHANGE COLUMN ${column.join(' ')}`;
        });
        const removePrimaries = build.primary.remove.map(name => `DROP PRIMARY KEY ${exports.q}${name}${exports.q}`);
        const addPrimaries = build.primary.add.length
            ? [`ADD PRIMARY KEY (${exports.q}${build.primary.add.join(`${exports.q}, ${exports.q}`)}${exports.q})`]
            : [];
        const removeUniques = build.unique.remove.map(name => `DROP UNIQUE ${exports.q}${name}${exports.q}`);
        const addUniques = Object.keys(build.unique.add).map(key => `ADD UNIQUE ${exports.q}${key}${exports.q} (${exports.q}${build.unique.add[key].join(`${exports.q}, ${exports.q}`)}${exports.q})`);
        const removeKeys = build.keys.remove.map(name => `DROP INDEX ${exports.q}${name}${exports.q}`);
        const addKeys = Object.keys(build.keys.add).map(key => `ADD INDEX ${exports.q}${key}${exports.q} (${exports.q}${build.keys.add[key].join(`${exports.q}, ${exports.q}`)}${exports.q})`);
        const removeForeignKeys = build.foreign.remove.map(name => `DROP FOREIGN KEY ${exports.q}${name}${exports.q}`);
        const addForeignKeys = Object.entries(build.foreign.add).map(([name, info]) => {
            return [
                `ADD CONSTRAINT ${exports.q}${name}${exports.q} FOREIGN KEY (${exports.q}${info.local}${exports.q})`,
                `REFERENCES ${exports.q}${info.table}${exports.q}(${exports.q}${info.foreign}${exports.q})`,
                info.delete ? `ON DELETE ${info.delete}` : '',
                info.update ? `ON UPDATE ${info.update}` : ''
            ].join(' ');
        });
        if (!removeFields.length
            && !addFields.length
            && !changeFields.length
            && !removePrimaries.length
            && !addPrimaries.length
            && !removeUniques.length
            && !addUniques.length
            && !removeKeys.length
            && !addKeys.length
            && !removeForeignKeys.length
            && !addForeignKeys.length) {
            throw Exception_js_1.default.for('No alterations made.');
        }
        query.push(...removeFields, ...addFields, ...changeFields, ...removePrimaries, ...addPrimaries, ...removeUniques, ...addUniques, ...removeKeys, ...addKeys, ...removeForeignKeys, ...addForeignKeys);
        return [
            {
                query: `ALTER TABLE ${exports.q}${build.table}${exports.q} (${query.join(', ')})`,
                values: []
            }
        ];
    },
    create(builder) {
        const build = builder.build();
        if (!Object.values(build.fields).length) {
            throw Exception_js_1.default.for('No fields provided');
        }
        const query = [];
        const fields = Object.keys(build.fields).map(name => {
            const field = build.fields[name];
            const column = [];
            const { type, length } = getType(field.type, field.length);
            column.push(`${exports.q}${name}${exports.q}`);
            if (Array.isArray(length)) {
                column.push(`${type}(${length.join(', ')})`);
            }
            else if (length) {
                column.push(`${type}(${length})`);
            }
            else {
                column.push(type);
            }
            field.attribute && column.push(field.attribute);
            field.unsigned && column.push('UNSIGNED');
            field.nullable && column.push('NOT NULL');
            field.autoIncrement && column.push('AUTO_INCREMENT');
            if (field.default) {
                if (typeof field.default === 'boolean') {
                    column.push(`DEFAULT ${field.default ? 'TRUE' : 'FALSE'}`);
                }
                else if (!isNaN(Number(field.default))) {
                    column.push(`DEFAULT ${field.default}`);
                }
                else if (typeof field.default === 'string'
                    && field.default.endsWith('()')) {
                    column.push(`DEFAULT ${field.default.toUpperCase()}`);
                }
                else {
                    column.push(`DEFAULT '${field.default}'`);
                }
            }
            else if (field.nullable) {
                column.push('DEFAULT NULL');
            }
            return column.join(' ');
        }).join(', ');
        query.push(fields);
        if (build.primary.length) {
            query.push(`, PRIMARY KEY (${build.primary
                .map(key => `${exports.q}${key}${exports.q}`)
                .join(', ')})`);
        }
        if (Object.keys(build.keys).length) {
            query.push(', ' + Object.keys(build.unique).map(key => `UNIQUE KEY ${exports.q}${key}${exports.q} (${exports.q}${build.unique[key].join(`${exports.q}, ${exports.q}`)}${exports.q})`).join(', '));
        }
        if (Object.keys(build.keys).length) {
            query.push(', ' + Object.keys(build.keys).map(key => `KEY ${exports.q}${key}${exports.q} (${exports.q}${build.keys[key].join(`${exports.q}, ${exports.q}`)}${exports.q})`).join(', '));
        }
        if (Object.keys(build.foreign).length) {
            query.push(', ' + Object.entries(build.foreign).map(([name, info]) => {
                return [
                    `CONSTRAINT ${exports.q}${name}${exports.q} FOREIGN KEY (${exports.q}${info.local}${exports.q})`,
                    `REFERENCES ${exports.q}${info.table}${exports.q}(${exports.q}${info.foreign}${exports.q})`,
                    info.delete ? `ON DELETE ${info.delete}` : '',
                    info.update ? `ON UPDATE ${info.update}` : ''
                ].join(' ');
            }).join(', '));
        }
        return [
            {
                query: `CREATE TABLE IF NOT EXISTS ${exports.q}${build.table}${exports.q} (${query.join(' ')})`,
                values: []
            }
        ];
    },
    delete(builder) {
        const build = builder.build();
        if (!build.filters.length) {
            throw Exception_js_1.default.for('No filters provided');
        }
        const query = [];
        const values = [];
        query.push(`DELETE FROM ${exports.q}${build.table}${exports.q}`);
        const filters = build.filters.map(filter => {
            values.push(...filter[1]);
            return filter[0];
        }).join(' AND ');
        query.push(`WHERE ${filters}`);
        return { query: query.join(' '), values };
    },
    drop(table) {
        return { query: `DROP TABLE IF EXISTS ${exports.q}${table}${exports.q}`, values: [] };
    },
    insert(builder) {
        const build = builder.build();
        if (build.values.length === 0) {
            throw Exception_js_1.default.for('No values provided');
        }
        const query = [];
        const values = [];
        query.push(`INSERT INTO ${exports.q}${build.table}${exports.q}`);
        const keys = Object.keys(build.values[0]);
        query.push(`(${exports.q}${keys.join(`${exports.q}, ${exports.q}`)}${exports.q})`);
        const row = build.values.map((value) => {
            const row = keys.map(key => value[key]);
            values.push(...row);
            return `(${row.map(() => '?').join(', ')})`;
        });
        query.push(`VALUES ${row.join(', ')}`);
        return { query: query.join(' '), values };
    },
    rename(from, to) {
        return {
            query: `RENAME TABLE ${exports.q}${from}${exports.q} TO ${exports.q}${to}${exports.q}`,
            values: []
        };
    },
    select(builder) {
        const build = builder.build();
        if (!build.table) {
            throw Exception_js_1.default.for('No table specified');
        }
        const query = [];
        const values = [];
        const columns = build.columns
            .map(column => column.split(','))
            .flat(1)
            .map(column => column.trim())
            .filter(Boolean);
        query.push(`SELECT ${columns.join(', ')}`);
        if (build.table) {
            if (build.table[1] !== build.table[0]) {
                query.push(`FROM ${exports.q}${build.table[0]}${exports.q} AS ${exports.q}${build.table[1]}${exports.q}`);
            }
            else {
                query.push(`FROM ${exports.q}${build.table[0]}${exports.q}`);
            }
        }
        if (build.relations.length) {
            const relations = build.relations.map(relation => {
                const type = relation.type;
                const table = relation.table !== relation.as
                    ? `${exports.q}${relation.table}${exports.q} AS ${exports.q}${relation.as}${exports.q}`
                    : `${exports.q}${relation.table}${exports.q}`;
                return `${helpers_js_1.joins[type]} JOIN ${table} ON (${exports.q}${relation.from}${exports.q} = ${exports.q}${relation.to}${exports.q})`;
            });
            query.push(relations.join(' '));
        }
        if (build.filters.length) {
            const filters = build.filters.map(filter => {
                values.push(...filter[1]);
                return filter[0];
            }).join(' AND ');
            query.push(`WHERE ${filters}`);
        }
        if (build.sort.length) {
            const sort = build.sort.map((sort) => `${exports.q}${sort[0]}${exports.q} ${sort[1].toUpperCase()}`);
            query.push(`ORDER BY ${sort.join(`, `)}`);
        }
        if (build.limit) {
            query.push(`LIMIT ${build.limit}`);
        }
        if (build.offset) {
            query.push(`OFFSET ${build.offset}`);
        }
        return { query: query.join(' '), values };
    },
    truncate(table, cascade = false) {
        return {
            query: `TRUNCATE TABLE ${exports.q}${table}${exports.q}${cascade ? ' CASCADE' : ''}`,
            values: []
        };
    },
    update(builder) {
        const build = builder.build();
        if (!Object.keys(build.data).length) {
            throw Exception_js_1.default.for('No data provided');
        }
        const query = [];
        const values = [];
        query.push(`UPDATE ${exports.q}${build.table}${exports.q}`);
        if (Object.keys(build.data).length) {
            const data = Object.keys(build.data).map(key => {
                values.push(build.data[key]);
                return `${exports.q}${key}${exports.q} = ?`;
            }).join(', ');
            query.push(`SET ${data}`);
        }
        if (build.filters.length) {
            const filters = build.filters.map(filter => {
                values.push(...filter[1]);
                return filter[0];
            }).join(' AND ');
            query.push(`WHERE ${filters}`);
        }
        return { query: query.join(' '), values };
    },
};
exports.default = Mysql;
