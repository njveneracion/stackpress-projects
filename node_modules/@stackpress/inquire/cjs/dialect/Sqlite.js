"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.typemap = exports.q = void 0;
exports.getType = getType;
const Exception_js_1 = __importDefault(require("../Exception.js"));
const helpers_js_1 = require("../helpers.js");
exports.q = '`';
exports.typemap = {
    object: 'TEXT',
    hash: 'TEXT',
    json: 'TEXT',
    char: 'CHAR',
    string: 'VARCHAR',
    varchar: 'VARCHAR',
    text: 'TEXT',
    bool: 'INTEGER',
    boolean: 'INTEGER',
    number: 'INTEGER',
    int: 'INTEGER',
    integer: 'INTEGER',
    float: 'REAL',
    date: 'INTEGER',
    datetime: 'INTEGER',
    time: 'INTEGER'
};
function getType(key, length) {
    let type = exports.typemap[key.toLowerCase()] || key.toUpperCase();
    if (!Array.isArray(length)) {
        if (type === 'CHAR' || type === 'VARCHAR') {
            length = length || 255;
        }
        if (type === 'INTEGER' || type === 'REAL') {
            length = undefined;
        }
    }
    return { type, length };
}
;
const Sqlite = {
    q: exports.q,
    alter(builder) {
        const build = builder.build();
        const transactions = [];
        build.fields.remove.forEach(name => {
            transactions.push({
                query: `ALTER TABLE ${exports.q}${build.table}${exports.q} DROP COLUMN ${exports.q}${name}${exports.q}`,
                values: []
            });
        });
        Object.keys(build.fields.add).forEach(name => {
            const field = build.fields.add[name];
            const column = [];
            const { type, length } = getType(field.type, field.length);
            column.push(`${exports.q}${name}${exports.q}`);
            if (type === 'REAL' || type === 'INTEGER') {
                column.push(type);
            }
            else if (Array.isArray(length)) {
                column.push(`${type}(${length.join(', ')})`);
            }
            else if (length) {
                column.push(`${type}(${length})`);
            }
            else {
                column.push(type);
            }
            field.attribute && column.push(field.attribute);
            field.nullable && column.push('NOT NULL');
            field.autoIncrement && column.push('AUTOINCREMENT');
            if (field.default) {
                if (typeof field.default === 'boolean') {
                    column.push(`DEFAULT ${field.default ? '1' : '0'}`);
                }
                else if (!isNaN(Number(field.default))) {
                    column.push(`DEFAULT ${field.default}`);
                }
                else if (typeof field.default === 'string'
                    && field.default.toUpperCase() === 'NOW()') {
                    column.push('DEFAULT CURRENT_TIMESTAMP');
                }
                else if (typeof field.default === 'string'
                    && field.default.endsWith('()')) {
                    column.push(`DEFAULT ${field.default.toUpperCase()}`);
                }
                else {
                    column.push(`DEFAULT '${field.default}'`);
                }
            }
            else if (field.nullable) {
                column.push('DEFAULT NULL');
            }
            transactions.push({
                query: `ALTER TABLE ${exports.q}${build.table}${exports.q} ADD COLUMN ${column.join(' ')}`,
                values: []
            });
        });
        Object.keys(build.fields.update).map(name => {
            const field = build.fields.update[name];
            let { type, length } = getType(field.type, field.length);
            if (type === 'REAL' || type === 'INTEGER') {
            }
            else if (Array.isArray(length)) {
                type = `${type}(${length.join(', ')})`;
            }
            else if (length) {
                type = `${type}(${length})`;
            }
            transactions.push({
                query: `ALTER TABLE ${exports.q}${build.table}${exports.q} ALTER COLUMN ${exports.q}${name}${exports.q} SET DATA TYPE ${type}`,
                values: []
            });
        });
        build.unique.remove.forEach(name => {
            transactions.push({
                query: `DROP INDEX ${exports.q}${name}${exports.q}`,
                values: []
            });
        });
        Object.entries(build.unique.add).forEach(([name, values]) => {
            transactions.push({
                query: `CREATE UNIQUE INDEX ${exports.q}${name}${exports.q} ON ${exports.q}${build.table}${exports.q}(${exports.q}${values.join(`${exports.q}, ${exports.q}`)}${exports.q})`,
                values: []
            });
        });
        build.keys.remove.forEach(name => {
            transactions.push({
                query: `DROP INDEX ${exports.q}${name}${exports.q}`,
                values: []
            });
        });
        Object.entries(build.keys.add).forEach(([name, values]) => {
            transactions.push({
                query: `CREATE INDEX ${exports.q}${name}${exports.q} ON ${exports.q}${build.table}${exports.q}(${exports.q}${values.join(`${exports.q}, ${exports.q}`)}${exports.q})`,
                values: []
            });
        });
        if (transactions.length === 0) {
            throw Exception_js_1.default.for('No alterations made.');
        }
        return transactions;
    },
    create(builder) {
        const build = builder.build();
        if (!Object.values(build.fields).length) {
            throw Exception_js_1.default.for('No fields provided');
        }
        const transactions = [];
        const fields = Object.keys(build.fields).map(name => {
            const field = build.fields[name];
            const column = [];
            const { type, length } = getType(field.type, field.length);
            column.push(`${exports.q}${name}${exports.q}`);
            if (type === 'REAL' || type === 'INTEGER') {
                column.push(type);
            }
            else if (Array.isArray(length)) {
                column.push(`${type}(${length.join(', ')})`);
            }
            else if (length) {
                column.push(`${type}(${length})`);
            }
            else {
                column.push(type);
            }
            field.attribute && column.push(field.attribute);
            field.nullable && column.push('NOT NULL');
            if (field.default) {
                if (typeof field.default === 'boolean') {
                    column.push(`DEFAULT ${field.default ? '1' : '0'}`);
                }
                else if (!isNaN(Number(field.default))) {
                    column.push(`DEFAULT ${field.default}`);
                }
                else if (typeof field.default === 'string'
                    && field.default.toUpperCase() === 'NOW()') {
                    column.push('DEFAULT CURRENT_TIMESTAMP');
                }
                else if (typeof field.default === 'string'
                    && field.default.endsWith('()')) {
                    column.push(`DEFAULT ${field.default.toUpperCase()}`);
                }
                else {
                    column.push(`DEFAULT '${field.default}'`);
                }
            }
            else if (field.nullable) {
                column.push('DEFAULT NULL');
            }
            if (build.primary.includes(name)) {
                column.push('PRIMARY KEY');
            }
            field.autoIncrement && column.push('AUTOINCREMENT');
            return column.join(' ');
        });
        if (Object.keys(build.foreign).length) {
            fields.push(...Object.values(build.foreign).map(info => {
                return [
                    `FOREIGN KEY (${exports.q}${info.local}${exports.q})`,
                    `REFERENCES ${exports.q}${info.table}${exports.q}(${exports.q}${info.foreign}${exports.q})`,
                    info.delete ? `ON DELETE ${info.delete}` : '',
                    info.update ? `ON UPDATE ${info.update}` : ''
                ].join(' ');
            }));
        }
        transactions.push({
            query: `CREATE TABLE IF NOT EXISTS ${exports.q}${build.table}${exports.q} (${fields.join(', ')})`,
            values: []
        });
        Object.entries(build.unique).forEach(([name, values]) => {
            transactions.push({
                query: `CREATE UNIQUE INDEX ${exports.q}${name}${exports.q} ON ${exports.q}${build.table}${exports.q}(${exports.q}${values.join(`${exports.q}, ${exports.q}`)}${exports.q})`,
                values: []
            });
        });
        Object.entries(build.keys).forEach(([name, values]) => {
            transactions.push({
                query: `CREATE INDEX ${exports.q}${name}${exports.q} ON ${exports.q}${build.table}${exports.q}(${exports.q}${values.join(`${exports.q}, ${exports.q}`)}${exports.q})`,
                values: []
            });
        });
        return transactions;
    },
    delete(builder) {
        const build = builder.build();
        if (!build.filters.length) {
            throw Exception_js_1.default.for('No filters provided');
        }
        const query = [];
        const values = [];
        query.push(`DELETE FROM ${exports.q}${build.table}${exports.q}`);
        const filters = build.filters.map(filter => {
            values.push(...filter[1]);
            return filter[0];
        }).join(' AND ');
        query.push(`WHERE ${filters}`);
        return { query: query.join(' '), values };
    },
    drop(table) {
        return { query: `DROP TABLE IF EXISTS ${exports.q}${table}${exports.q}`, values: [] };
    },
    insert(builder) {
        const build = builder.build();
        if (build.values.length === 0) {
            throw Exception_js_1.default.for('No values provided');
        }
        const query = [];
        const values = [];
        query.push(`INSERT INTO ${exports.q}${build.table}${exports.q}`);
        const keys = Object.keys(build.values[0]);
        query.push(`(${exports.q}${keys.join(`${exports.q}, ${exports.q}`)}${exports.q})`);
        const row = build.values.map((value) => {
            const row = keys.map(key => value[key]);
            values.push(...row);
            return `(${row.map(() => '?').join(', ')})`;
        });
        query.push(`VALUES ${row.join(', ')}`);
        if (build.returning.length) {
            query.push(`RETURNING ${build.returning.map(column => column !== '*' ? `${exports.q}${column}${exports.q}` : column).join(', ')}`);
        }
        return { query: query.join(' '), values };
    },
    rename(from, to) {
        return {
            query: `ALTER TABLE ${exports.q}${from}${exports.q} RENAME TO ${exports.q}${to}${exports.q}`,
            values: []
        };
    },
    select(builder) {
        const build = builder.build();
        if (!build.table) {
            throw Exception_js_1.default.for('No table specified');
        }
        const query = [];
        const values = [];
        const columns = build.columns
            .map(column => column.split(','))
            .flat(1)
            .map(column => column.trim())
            .filter(Boolean);
        query.push(`SELECT ${columns.join(', ')}`);
        if (build.table) {
            if (build.table[1] !== build.table[0]) {
                query.push(`FROM ${exports.q}${build.table[0]}${exports.q} AS ${exports.q}${build.table[1]}${exports.q}`);
            }
            else {
                query.push(`FROM ${exports.q}${build.table[0]}${exports.q}`);
            }
        }
        if (build.relations.length) {
            const relations = build.relations.map(relation => {
                const type = relation.type;
                const table = relation.table !== relation.as
                    ? `${exports.q}${relation.table}${exports.q} AS ${exports.q}${relation.as}${exports.q}`
                    : `${exports.q}${relation.table}${exports.q}`;
                return `${helpers_js_1.joins[type]} JOIN ${table} ON (${exports.q}${relation.from}${exports.q} = ${exports.q}${relation.to}${exports.q})`;
            });
            query.push(relations.join(' '));
        }
        if (build.filters.length) {
            const filters = build.filters.map(filter => {
                values.push(...filter[1]);
                return filter[0];
            }).join(' AND ');
            query.push(`WHERE ${filters}`);
        }
        if (build.sort.length) {
            const sort = build.sort.map((sort) => `${exports.q}${sort[0]}${exports.q} ${sort[1].toUpperCase()}`);
            query.push(`ORDER BY ${sort.join(`, `)}`);
        }
        if (build.limit) {
            query.push(`LIMIT ${build.limit}`);
        }
        if (build.offset) {
            query.push(`OFFSET ${build.offset}`);
        }
        return { query: query.join(' '), values };
    },
    truncate(table, cascade = false) {
        return {
            query: `TRUNCATE TABLE ${exports.q}${table}${exports.q}${cascade ? ' CASCADE' : ''}`,
            values: []
        };
    },
    update(builder) {
        const build = builder.build();
        if (!Object.keys(build.data).length) {
            throw Exception_js_1.default.for('No data provided');
        }
        const query = [];
        const values = [];
        query.push(`UPDATE ${exports.q}${build.table}${exports.q}`);
        if (Object.keys(build.data).length) {
            const data = Object.keys(build.data).map(key => {
                values.push(build.data[key]);
                return `${exports.q}${key}${exports.q} = ?`;
            }).join(', ');
            query.push(`SET ${data}`);
        }
        if (build.filters.length) {
            const filters = build.filters.map(filter => {
                values.push(...filter[1]);
                return filter[0];
            }).join(' AND ');
            query.push(`WHERE ${filters}`);
        }
        return { query: query.join(' '), values };
    },
};
exports.default = Sqlite;
