import Alter from './builder/Alter.js';
import Create from './builder/Create.js';
import Delete from './builder/Delete.js';
import Insert from './builder/Insert.js';
import Select from './builder/Select.js';
import Update from './builder/Update.js';
import { jsonCompare } from './helpers.js';
export default class Engine {
    connection;
    get dialect() {
        return this.connection.dialect;
    }
    constructor(connection) {
        this.connection = connection;
    }
    alter(table) {
        return new Alter(table, this);
    }
    create(table) {
        return new Create(table, this);
    }
    delete(table) {
        return new Delete(table, this);
    }
    diff(from, to) {
        const build = {
            from: from.build(),
            to: to.build()
        };
        const alter = this.alter(build.from.table);
        for (const name in build.from.fields) {
            if (!build.to.fields[name]) {
                alter.removeField(name);
                continue;
            }
            const from = build.from.fields[name];
            const to = build.to.fields[name];
            if (from.type !== to.type
                || from.length !== to.length
                || from.nullable !== to.nullable
                || from.default !== to.default
                || from.autoIncrement !== to.autoIncrement
                || from.attribute !== to.attribute
                || from.comment !== to.comment
                || from.unsigned !== to.unsigned) {
                alter.changeField(name, to);
            }
        }
        for (const name of build.from.primary) {
            if (!build.to.primary.includes(name)) {
                alter.removePrimaryKey(name);
            }
        }
        for (const name in build.from.unique) {
            if (!build.to.unique[name]) {
                alter.removeUniqueKey(name);
                continue;
            }
            if (!jsonCompare(build.from.unique[name], build.to.unique[name])) {
                alter.removeUniqueKey(name);
                alter.addUniqueKey(name, build.to.unique[name]);
            }
        }
        for (const name in build.from.keys) {
            if (!build.to.keys[name]) {
                alter.removeKey(name);
                continue;
            }
            if (!jsonCompare(build.from.keys[name], build.to.keys[name])) {
                alter.removeKey(name);
                alter.addKey(name, build.to.keys[name]);
            }
        }
        for (const name in build.from.foreign) {
            if (!build.to.foreign[name]) {
                alter.removeForeignKey(name);
                continue;
            }
            if (!jsonCompare(build.from.foreign[name], build.to.foreign[name])) {
                alter.removeForeignKey(name);
                alter.addForeignKey(name, build.to.foreign[name]);
            }
        }
        for (const name in build.to.fields) {
            if (!build.from.fields[name]) {
                alter.addField(name, build.to.fields[name]);
            }
        }
        for (const name of build.to.primary) {
            if (!build.from.primary.includes(name)) {
                alter.addPrimaryKey(name);
            }
        }
        for (const name in build.to.unique) {
            if (!build.from.unique[name]) {
                alter.addUniqueKey(name, build.to.unique[name]);
            }
        }
        for (const name in build.to.keys) {
            if (!build.from.keys[name]) {
                alter.addKey(name, build.to.keys[name]);
            }
        }
        for (const name in build.to.foreign) {
            if (!build.from.foreign[name]) {
                alter.addForeignKey(name, build.to.foreign[name]);
            }
        }
        return alter;
    }
    drop(table) {
        const { query, values } = this.dialect.drop(table);
        return this.query(query, values);
    }
    insert(table) {
        return new Insert(table, this);
    }
    query(query, values = []) {
        if (typeof query === 'string') {
            query = { query, values };
        }
        return this.connection.query(query);
    }
    rename(from, to) {
        const { query, values } = this.dialect.rename(from, to);
        return this.query(query, values);
    }
    select(columns) {
        return new Select(columns, this);
    }
    sql(strings, ...values) {
        const query = strings.join('?').replaceAll('`', this.dialect.q);
        return this.query(query, values);
    }
    transaction(callback) {
        return this.connection.transaction(callback);
    }
    truncate(table, cascade = false) {
        const { query, values } = this.dialect.truncate(table, cascade);
        return this.query(query, values);
    }
    update(table) {
        return new Update(table, this);
    }
}
