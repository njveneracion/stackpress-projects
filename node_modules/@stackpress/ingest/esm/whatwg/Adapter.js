import { Readable } from 'node:stream';
import cookie from '@stackpress/lib/cookie';
import { isObject, objectFromQuery, formDataToObject } from '@stackpress/lib/Nest';
import Route from '../Route.js';
import Request from '../Request.js';
import Response from '../Response.js';
import { WhatwgResponse, reqToURL, readableToReadableStream } from './helpers.js';
export default class Adapter {
    static async plug(context, request, action) {
        const server = new Adapter(context, request);
        return server.plug(action);
    }
    ;
    _context;
    _request;
    constructor(context, request) {
        this._context = context;
        this._request = request;
    }
    async plug(action) {
        const req = this.request();
        const res = this.response();
        const event = action || `${req.method} ${req.url.pathname}`;
        await req.load();
        await Route.emit(event, req, res, this._context);
        if (!res.sent) {
            return res.dispatch();
        }
        return res.resource;
    }
    request() {
        const resource = this._request;
        const method = (this._request.method?.toUpperCase() || 'GET');
        const mimetype = this._request.headers.get('content-type') || 'text/plain';
        const headers = {};
        this._request.headers.forEach((value, key) => {
            if (typeof value !== 'undefined') {
                headers[key] = value;
            }
        });
        const session = cookie.parse(this._request.headers.get('cookie') || '');
        const url = reqToURL(this._request);
        const query = objectFromQuery(url.searchParams.toString());
        const request = new Request({
            resource,
            headers,
            method,
            mimetype,
            query,
            session,
            url
        });
        request.loader = loader(this._request);
        return request;
    }
    response() {
        const response = new Response();
        response.dispatcher = dispatcher(this._context.config('cookie') || { path: '/' });
        return response;
    }
}
;
export function loader(resource) {
    return async (req) => {
        if (req.body !== null) {
            return undefined;
        }
        const body = await resource.text();
        const post = formDataToObject(req.type, body);
        return { body, post };
    };
}
;
export function dispatcher(options = { path: '/' }) {
    return async (res) => {
        if (res.resource instanceof WhatwgResponse) {
            return res.resource;
        }
        let mimetype = res.mimetype;
        let body = null;
        if (typeof res.body === 'string'
            || Buffer.isBuffer(res.body)
            || res.body instanceof Uint8Array
            || res.body instanceof ReadableStream) {
            body = res.body;
        }
        else if (res.body instanceof Readable) {
            body = readableToReadableStream(res.body);
        }
        else if (isObject(res.body) || Array.isArray(res.body)) {
            res.mimetype = 'application/json';
            body = JSON.stringify({
                code: res.code,
                status: res.status,
                results: res.body,
                error: res.error,
                errors: res.errors.size > 0 ? res.errors.get() : undefined,
                total: res.total > 0 ? res.total : undefined
            });
        }
        else if (res.code && res.status) {
            res.mimetype = 'application/json';
            body = JSON.stringify({
                code: res.code,
                status: res.status,
                error: res.error,
                errors: res.errors.size > 0 ? res.errors.get() : undefined,
                stack: res.stack ? res.stack : undefined
            });
        }
        const resource = new WhatwgResponse(body, {
            status: res.code,
            statusText: res.status
        });
        for (const [name, entry] of res.session.revisions.entries()) {
            if (entry.action === 'remove') {
                resource.headers.set('Set-Cookie', cookie.serialize(name, '', { ...options, expires: new Date(0) }));
            }
            else if (entry.action === 'set'
                && typeof entry.value !== 'undefined') {
                const { value } = entry;
                const values = Array.isArray(value) ? value : [value];
                for (const value of values) {
                    resource.headers.set('Set-Cookie', cookie.serialize(name, value, options));
                }
            }
        }
        for (const [name, value] of res.headers.entries()) {
            const values = Array.isArray(value) ? value : [value];
            for (const value of values) {
                resource.headers.set(name, value);
            }
        }
        if (mimetype) {
            resource.headers.set('Content-Type', mimetype);
        }
        return resource;
    };
}
;
