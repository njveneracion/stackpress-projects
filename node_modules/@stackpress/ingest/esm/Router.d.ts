import type { Method, RequestOptions, ResponseOptions, StatusResponse } from '@stackpress/lib/types';
import type EntryRouter from './plugin/EntryRouter.js';
import type ImportRouter from './plugin/ImportRouter.js';
import type ViewRouter from './plugin/ViewRouter.js';
import ActionRouter from './plugin/ActionRouter.js';
import type { AnyRouterAction } from './types.js';
import Request from './Request.js';
import Response from './Response.js';
export default class Router<R = unknown, S = unknown> {
    readonly action: ActionRouter<R, S, this>;
    readonly entry: EntryRouter<R, S, this>;
    readonly import: ImportRouter<R, S, this>;
    readonly view: ViewRouter<R, S, this>;
    get entries(): Map<string, Set<import("./types.js").EntryRouterTaskItem>>;
    get expressions(): typeof this.action.expressions;
    get imports(): Map<string, Set<import("./types.js").ImportRouterTaskItem<R, S, this>>>;
    get listeners(): typeof this.action.listeners;
    get routes(): Map<string, import("@stackpress/lib/types").Route>;
    get views(): Map<string, Set<import("./types.js").ViewRouterTaskItem>>;
    constructor();
    all(path: string, action: AnyRouterAction<R, S, this>, priority?: number): this;
    connect(path: string, action: AnyRouterAction<R, S, this>, priority?: number): this;
    delete(path: string, action: AnyRouterAction<R, S, this>, priority?: number): this;
    emit(event: string, req: Request<R>, res: Response<S>): Promise<import("@stackpress/lib/types").ResponseStatus>;
    get(path: string, action: AnyRouterAction<R, S, this>, priority?: number): this;
    head(path: string, action: AnyRouterAction<R, S, this>, priority?: number): this;
    on(event: string | RegExp, action: AnyRouterAction<R, S, this>, priority?: number): this;
    options(path: string, action: AnyRouterAction<R, S, this>, priority?: number): this;
    patch(path: string, action: AnyRouterAction<R, S, this>, priority?: number): this;
    post(path: string, action: AnyRouterAction<R, S, this>, priority?: number): this;
    put(path: string, action: AnyRouterAction<R, S, this>, priority?: number): this;
    request(init?: Partial<RequestOptions<R>>): Request<R>;
    resolve<T = unknown>(event: string, request?: Request<R> | Record<string, any>, response?: Response<S>): Promise<Partial<StatusResponse<T>>>;
    resolve<T = unknown>(method: Method | '*', path: string, request?: Request<R> | Record<string, any>, response?: Response<S>): Promise<Partial<StatusResponse<T>>>;
    response(init?: Partial<ResponseOptions<S>>): Response<S>;
    route(method: Method, path: string, action: AnyRouterAction<R, S, this>, priority?: number): this;
    trace(path: string, action: AnyRouterAction<R, S, this>, priority?: number): this;
    use<T extends Router<R, S>>(router: T): this;
    protected _resolveEvent<T = unknown>(event: string, request?: Request<R> | Record<string, any>, response?: Response<S>): Promise<Partial<Partial<import("@stackpress/lib/types").ResponseStatus & {
        error: string;
        errors?: import("@stackpress/lib/types").NestedObject<string | string[]>;
        start?: number;
        end?: number;
        stack?: import("@stackpress/lib/types").Trace[];
    } & {
        results: T;
        total?: number;
    }>>>;
    protected _resolveRoute<T = unknown>(method: string, path: string, request?: Request<R> | Record<string, any>, response?: Response<S>): Promise<Partial<Partial<import("@stackpress/lib/types").ResponseStatus & {
        error: string;
        errors?: import("@stackpress/lib/types").NestedObject<string | string[]>;
        start?: number;
        end?: number;
        stack?: import("@stackpress/lib/types").Trace[];
    } & {
        results: T;
        total?: number;
    }>>>;
}
