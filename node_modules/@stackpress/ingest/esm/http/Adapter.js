import { Readable } from 'node:stream';
import cookie from '@stackpress/lib/cookie';
import { isObject, objectFromQuery, formDataToObject } from '@stackpress/lib/Nest';
import Route from '../Route.js';
import Request from '../Request.js';
import Response from '../Response.js';
import Exception from '../Exception.js';
import { imToURL, readableStreamToReadable } from './helpers.js';
export default class Adapter {
    static async plug(context, request, response, action) {
        const server = new Adapter(context, request, response);
        return server.plug(action);
    }
    ;
    _context;
    _request;
    _response;
    constructor(context, request, response) {
        this._context = context;
        this._request = request;
        this._response = response;
    }
    async plug(action) {
        const req = this.request();
        const res = this.response();
        const event = action || `${req.method} ${req.url.pathname}`;
        await req.load();
        await Route.emit(event, req, res, this._context);
        if (!res.sent) {
            return res.dispatch();
        }
        return res.resource;
    }
    request() {
        const resource = this._request;
        const method = (this._request.method?.toUpperCase() || 'GET');
        const mimetype = this._request.headers['content-type'] || 'text/plain';
        const headers = Object.fromEntries(Object.entries(this._request.headers).filter(([_key, value]) => typeof value !== 'undefined'));
        const session = cookie.parse(this._request.headers.cookie || '');
        const url = imToURL(this._request);
        const query = objectFromQuery(url.searchParams.toString());
        const request = new Request({
            resource,
            headers,
            method,
            mimetype,
            query,
            session,
            url
        });
        request.loader = loader(this._request);
        return request;
    }
    response() {
        const response = new Response({ resource: this._response });
        response.dispatcher = dispatcher(this._context.config('cookie') || { path: '/' });
        return response;
    }
}
export function loader(resource, size = 0) {
    return (req) => {
        return new Promise(resolve => {
            if (req.body !== null) {
                resolve(undefined);
            }
            let body = '';
            resource.on('data', chunk => {
                body += chunk;
                Exception.require(!size || body.length <= size, `Request exceeds ${size}`);
            });
            resource.on('end', () => {
                resolve({ body, post: formDataToObject(req.mimetype, body) });
            });
        });
    };
}
;
export function dispatcher(options = { path: '/' }) {
    return async (res) => {
        const resource = res.resource;
        resource.statusCode = res.code;
        resource.statusMessage = res.status;
        for (const [name, entry] of res.session.revisions.entries()) {
            if (entry.action === 'remove') {
                resource.setHeader('Set-Cookie', cookie.serialize(name, '', { ...options, expires: new Date(0) }));
            }
            else if (entry.action === 'set'
                && typeof entry.value !== 'undefined') {
                const { value } = entry;
                const values = Array.isArray(value) ? value : [value];
                for (const value of values) {
                    resource.setHeader('Set-Cookie', cookie.serialize(name, value, options));
                }
            }
        }
        for (const [name, value] of res.headers.entries()) {
            resource.setHeader(name, value);
        }
        if (res.mimetype) {
            resource.setHeader('Content-Type', res.mimetype);
        }
        if (typeof res.body === 'string'
            || Buffer.isBuffer(res.body)
            || res.body instanceof Uint8Array) {
            resource.end(res.body);
        }
        else if (res.body instanceof Readable) {
            res.body.pipe(resource);
        }
        else if (res.body instanceof ReadableStream) {
            readableStreamToReadable(res.body).pipe(resource);
        }
        else if (isObject(res.body) || Array.isArray(res.body)) {
            resource.setHeader('Content-Type', 'application/json');
            resource.end(JSON.stringify({
                code: res.code,
                status: res.status,
                results: res.body,
                error: res.error,
                errors: res.errors.size > 0 ? res.errors.get() : undefined,
                total: res.total > 0 ? res.total : undefined,
                stack: res.stack ? res.stack : undefined
            }));
        }
        else if (res.code && res.status) {
            resource.setHeader('Content-Type', 'application/json');
            resource.end(JSON.stringify({
                code: res.code,
                status: res.status,
                error: res.error,
                errors: res.errors.size > 0 ? res.errors.get() : undefined,
                stack: res.stack ? res.stack : undefined
            }));
        }
        return resource;
    };
}
;
