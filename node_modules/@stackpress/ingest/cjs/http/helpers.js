"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.imToURL = imToURL;
exports.imQueryToObject = imQueryToObject;
exports.readableStreamToReadable = readableStreamToReadable;
const node_stream_1 = require("node:stream");
const Nest_1 = require("@stackpress/lib/Nest");
const Request_1 = require("@stackpress/lib/Request");
function imToURL(resource) {
    let { url, headers } = resource;
    url = url === null || url === void 0 ? void 0 : url.replaceAll('//', '/');
    if (url === null || url === void 0 ? void 0 : url.endsWith('/')) {
        url = url.slice(0, -1);
    }
    let protocol = resource.socket.encrypted ? 'https' : 'http';
    const proto = headers['x-forwarded-proto'];
    if (proto === null || proto === void 0 ? void 0 : proto.length) {
        if (Array.isArray(proto)) {
            protocol = proto[0];
        }
        else {
            protocol = proto;
        }
        protocol = protocol.trim();
        if (protocol.indexOf(',') !== -1) {
            protocol = protocol.substring(0, protocol.indexOf(',')).trim();
        }
    }
    const uri = `${protocol}://${headers.host}${url || '/'}`;
    try {
        return new URL(uri);
    }
    catch (e) { }
    return new URL((0, Request_1.withUnknownHost)(url || '/'));
    ;
}
;
function imQueryToObject(resource) {
    return (0, Nest_1.objectFromQuery)(imToURL(resource).searchParams.toString());
}
;
function readableStreamToReadable(stream) {
    const reader = stream.getReader();
    return new node_stream_1.Readable({
        read(_size) {
            return __awaiter(this, void 0, void 0, function* () {
                const { done, value } = yield reader.read();
                if (done) {
                    this.push(null);
                    return;
                }
                this.push(value);
            });
        }
    });
}
;
