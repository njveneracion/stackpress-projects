"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loader = loader;
exports.dispatcher = dispatcher;
const node_stream_1 = require("node:stream");
const cookie_1 = __importDefault(require("@stackpress/lib/cookie"));
const Nest_1 = require("@stackpress/lib/Nest");
const Route_js_1 = __importDefault(require("../Route.js"));
const Request_js_1 = __importDefault(require("../Request.js"));
const Response_js_1 = __importDefault(require("../Response.js"));
const Exception_js_1 = __importDefault(require("../Exception.js"));
const helpers_js_1 = require("./helpers.js");
class Adapter {
    static plug(context, request, response, action) {
        return __awaiter(this, void 0, void 0, function* () {
            const server = new Adapter(context, request, response);
            return server.plug(action);
        });
    }
    ;
    constructor(context, request, response) {
        this._context = context;
        this._request = request;
        this._response = response;
    }
    plug(action) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = this.request();
            const res = this.response();
            const event = action || `${req.method} ${req.url.pathname}`;
            yield req.load();
            yield Route_js_1.default.emit(event, req, res, this._context);
            if (!res.sent) {
                return res.dispatch();
            }
            return res.resource;
        });
    }
    request() {
        var _a;
        const resource = this._request;
        const method = (((_a = this._request.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) || 'GET');
        const mimetype = this._request.headers['content-type'] || 'text/plain';
        const headers = Object.fromEntries(Object.entries(this._request.headers).filter(([_key, value]) => typeof value !== 'undefined'));
        const session = cookie_1.default.parse(this._request.headers.cookie || '');
        const url = (0, helpers_js_1.imToURL)(this._request);
        const query = (0, Nest_1.objectFromQuery)(url.searchParams.toString());
        const request = new Request_js_1.default({
            resource,
            headers,
            method,
            mimetype,
            query,
            session,
            url
        });
        request.loader = loader(this._request);
        return request;
    }
    response() {
        const response = new Response_js_1.default({ resource: this._response });
        response.dispatcher = dispatcher(this._context.config('cookie') || { path: '/' });
        return response;
    }
}
exports.default = Adapter;
function loader(resource, size = 0) {
    return (req) => {
        return new Promise(resolve => {
            if (req.body !== null) {
                resolve(undefined);
            }
            let body = '';
            resource.on('data', chunk => {
                body += chunk;
                Exception_js_1.default.require(!size || body.length <= size, `Request exceeds ${size}`);
            });
            resource.on('end', () => {
                resolve({ body, post: (0, Nest_1.formDataToObject)(req.mimetype, body) });
            });
        });
    };
}
;
function dispatcher(options = { path: '/' }) {
    return (res) => __awaiter(this, void 0, void 0, function* () {
        const resource = res.resource;
        resource.statusCode = res.code;
        resource.statusMessage = res.status;
        for (const [name, entry] of res.session.revisions.entries()) {
            if (entry.action === 'remove') {
                resource.setHeader('Set-Cookie', cookie_1.default.serialize(name, '', Object.assign(Object.assign({}, options), { expires: new Date(0) })));
            }
            else if (entry.action === 'set'
                && typeof entry.value !== 'undefined') {
                const { value } = entry;
                const values = Array.isArray(value) ? value : [value];
                for (const value of values) {
                    resource.setHeader('Set-Cookie', cookie_1.default.serialize(name, value, options));
                }
            }
        }
        for (const [name, value] of res.headers.entries()) {
            resource.setHeader(name, value);
        }
        if (res.mimetype) {
            resource.setHeader('Content-Type', res.mimetype);
        }
        if (typeof res.body === 'string'
            || Buffer.isBuffer(res.body)
            || res.body instanceof Uint8Array) {
            resource.end(res.body);
        }
        else if (res.body instanceof node_stream_1.Readable) {
            res.body.pipe(resource);
        }
        else if (res.body instanceof ReadableStream) {
            (0, helpers_js_1.readableStreamToReadable)(res.body).pipe(resource);
        }
        else if ((0, Nest_1.isObject)(res.body) || Array.isArray(res.body)) {
            resource.setHeader('Content-Type', 'application/json');
            resource.end(JSON.stringify({
                code: res.code,
                status: res.status,
                results: res.body,
                error: res.error,
                errors: res.errors.size > 0 ? res.errors.get() : undefined,
                total: res.total > 0 ? res.total : undefined,
                stack: res.stack ? res.stack : undefined
            }));
        }
        else if (res.code && res.status) {
            resource.setHeader('Content-Type', 'application/json');
            resource.end(JSON.stringify({
                code: res.code,
                status: res.status,
                error: res.error,
                errors: res.errors.size > 0 ? res.errors.get() : undefined,
                stack: res.stack ? res.stack : undefined
            }));
        }
        return resource;
    });
}
;
