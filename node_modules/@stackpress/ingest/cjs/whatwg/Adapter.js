"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loader = loader;
exports.dispatcher = dispatcher;
const node_stream_1 = require("node:stream");
const cookie_1 = __importDefault(require("@stackpress/lib/cookie"));
const Nest_1 = require("@stackpress/lib/Nest");
const Route_js_1 = __importDefault(require("../Route.js"));
const Request_js_1 = __importDefault(require("../Request.js"));
const Response_js_1 = __importDefault(require("../Response.js"));
const helpers_js_1 = require("./helpers.js");
class Adapter {
    static plug(context, request, action) {
        return __awaiter(this, void 0, void 0, function* () {
            const server = new Adapter(context, request);
            return server.plug(action);
        });
    }
    ;
    constructor(context, request) {
        this._context = context;
        this._request = request;
    }
    plug(action) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = this.request();
            const res = this.response();
            const event = action || `${req.method} ${req.url.pathname}`;
            yield req.load();
            yield Route_js_1.default.emit(event, req, res, this._context);
            if (!res.sent) {
                return res.dispatch();
            }
            return res.resource;
        });
    }
    request() {
        var _a;
        const resource = this._request;
        const method = (((_a = this._request.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) || 'GET');
        const mimetype = this._request.headers.get('content-type') || 'text/plain';
        const headers = {};
        this._request.headers.forEach((value, key) => {
            if (typeof value !== 'undefined') {
                headers[key] = value;
            }
        });
        const session = cookie_1.default.parse(this._request.headers.get('cookie') || '');
        const url = (0, helpers_js_1.reqToURL)(this._request);
        const query = (0, Nest_1.objectFromQuery)(url.searchParams.toString());
        const request = new Request_js_1.default({
            resource,
            headers,
            method,
            mimetype,
            query,
            session,
            url
        });
        request.loader = loader(this._request);
        return request;
    }
    response() {
        const response = new Response_js_1.default();
        response.dispatcher = dispatcher(this._context.config('cookie') || { path: '/' });
        return response;
    }
}
exports.default = Adapter;
;
function loader(resource) {
    return (req) => __awaiter(this, void 0, void 0, function* () {
        if (req.body !== null) {
            return undefined;
        }
        const body = yield resource.text();
        const post = (0, Nest_1.formDataToObject)(req.type, body);
        return { body, post };
    });
}
;
function dispatcher(options = { path: '/' }) {
    return (res) => __awaiter(this, void 0, void 0, function* () {
        if (res.resource instanceof helpers_js_1.WhatwgResponse) {
            return res.resource;
        }
        let mimetype = res.mimetype;
        let body = null;
        if (typeof res.body === 'string'
            || Buffer.isBuffer(res.body)
            || res.body instanceof Uint8Array
            || res.body instanceof ReadableStream) {
            body = res.body;
        }
        else if (res.body instanceof node_stream_1.Readable) {
            body = (0, helpers_js_1.readableToReadableStream)(res.body);
        }
        else if ((0, Nest_1.isObject)(res.body) || Array.isArray(res.body)) {
            res.mimetype = 'application/json';
            body = JSON.stringify({
                code: res.code,
                status: res.status,
                results: res.body,
                error: res.error,
                errors: res.errors.size > 0 ? res.errors.get() : undefined,
                total: res.total > 0 ? res.total : undefined
            });
        }
        else if (res.code && res.status) {
            res.mimetype = 'application/json';
            body = JSON.stringify({
                code: res.code,
                status: res.status,
                error: res.error,
                errors: res.errors.size > 0 ? res.errors.get() : undefined,
                stack: res.stack ? res.stack : undefined
            });
        }
        const resource = new helpers_js_1.WhatwgResponse(body, {
            status: res.code,
            statusText: res.status
        });
        for (const [name, entry] of res.session.revisions.entries()) {
            if (entry.action === 'remove') {
                resource.headers.set('Set-Cookie', cookie_1.default.serialize(name, '', Object.assign(Object.assign({}, options), { expires: new Date(0) })));
            }
            else if (entry.action === 'set'
                && typeof entry.value !== 'undefined') {
                const { value } = entry;
                const values = Array.isArray(value) ? value : [value];
                for (const value of values) {
                    resource.headers.set('Set-Cookie', cookie_1.default.serialize(name, value, options));
                }
            }
        }
        for (const [name, value] of res.headers.entries()) {
            const values = Array.isArray(value) ? value : [value];
            for (const value of values) {
                resource.headers.set(name, value);
            }
        }
        if (mimetype) {
            resource.headers.set('Content-Type', mimetype);
        }
        return resource;
    });
}
;
