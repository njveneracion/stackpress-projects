import type { TypeOf } from '../types.js';
import Router from './Router.js';
export declare function control(brand?: string): {
    brand: string;
    error(message: string, variables?: string[]): void;
    info(message: string, variables?: string[]): void;
    input(question: string, answer?: string): Promise<string>;
    output(message: string, variables?: string[], color?: string): void;
    success(message: string, variables?: string[]): void;
    system(message: string, variables?: string[]): void;
    warning(message: string, variables?: string[]): void;
};
export default class Terminal<R = unknown, S = unknown> extends Router<R, S, Terminal<R, S>> {
    readonly command: string;
    protected _control: ReturnType<typeof control>;
    protected _args: string[];
    protected _data?: Record<string, any>;
    get args(): string[];
    get brand(): string;
    get control(): Readonly<{
        brand: string;
        error(message: string, variables?: string[]): void;
        info(message: string, variables?: string[]): void;
        input(question: string, answer?: string): Promise<string>;
        output(message: string, variables?: string[], color?: string): void;
        success(message: string, variables?: string[]): void;
        system(message: string, variables?: string[]): void;
        warning(message: string, variables?: string[]): void;
    }>;
    get data(): {
        [x: string]: any;
    };
    constructor(args: string[], brand?: string);
    expect<T>(flags: string[], defaults: TypeOf<T>): T | TypeOf<T>;
    run<T = unknown>(): Promise<Partial<Partial<import("../types.js").ResponseStatus & {
        error: string;
        errors?: import("../types.js").NestedObject<string | string[]>;
        start?: number;
        end?: number;
        stack?: import("../types.js").Trace[];
    } & {
        results: T;
        total?: number;
    }>>>;
}
