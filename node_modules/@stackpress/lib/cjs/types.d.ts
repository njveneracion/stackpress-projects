import type { Readable } from 'node:stream';
import type { IncomingMessage, ServerResponse } from 'node:http';
import type Nest from './data/Nest.js';
import type { WriteSession } from './router/Session.js';
import type Request from './router/Request.js';
import type Response from './router/Response.js';
import type Router from './router/Router.js';
export type TypeOf<T> = T extends number ? number : T extends string ? string : T extends boolean ? boolean : T extends undefined ? any : T extends null ? null : T;
export type Key = string | number;
export interface NestedObject<V = unknown> {
    [key: Key]: V | NestedObject<V>;
}
export type UnknownNest = NestedObject<unknown>;
export type Scalar = string | number | boolean | null;
export type Hash = NestedObject<Scalar>;
export type ScalarInput = Scalar | Scalar[] | Hash;
export type FileMeta = {
    data: Buffer | string;
    name: string;
    type: string;
};
export type CallableSet<V = any> = ((index: number) => V | undefined) & Set<V> & {
    index: (index: number) => V | undefined;
};
export type CallableMap<K = any, V = any> = ((name: K) => V | undefined) & Map<K, V>;
export type CallableNest<M extends UnknownNest = UnknownNest> = (<T = any>(...path: Key[]) => T) & Nest<M>;
export type CookieOptions = {
    domain?: string;
    expires?: Date;
    httpOnly?: boolean;
    maxAge?: number;
    path?: string;
    partitioned?: boolean;
    priority?: 'low' | 'medium' | 'high';
    sameSite?: boolean | 'lax' | 'strict' | 'none';
    secure?: boolean;
};
export type CookieParseOptions = {
    decode?: (str: string) => string | undefined;
};
export type CookieSerializeOptions = CookieOptions & {
    encode?: (str: string) => string;
};
export type ResponseStatus = {
    code: number;
    status: string;
};
export type Trace = {
    method: string;
    file: string;
    line: number;
    char: number;
};
export type ErrorResponse = ResponseStatus & {
    error: string;
    errors?: NestedObject<string | string[]>;
    start?: number;
    end?: number;
    stack?: Trace[];
};
export type SuccessResponse<T = unknown> = ResponseStatus & {
    results: T;
    total?: number;
};
export type StatusResponse<T = unknown> = Partial<ErrorResponse & SuccessResponse<T>>;
export interface Item<I> {
    item: I;
    priority: number;
}
export type TaskResult = boolean | undefined | void | Promise<boolean | undefined | void>;
export type TaskAction<A extends Array<unknown>> = (...args: A) => TaskResult;
export type TaskItem<A extends Array<unknown>> = Item<TaskAction<A>>;
export type EventMap = Record<string, Array<unknown>>;
export type EventName<M extends EventMap> = string & keyof M;
export type EventData = {
    args: string[];
    params: Record<string, string>;
};
export type EventMatch = {
    event: string;
    pattern: string;
    data: EventData;
};
export type Event<A extends Array<unknown>> = TaskItem<A> & EventMatch & {
    args: A;
    action: TaskAction<A>;
};
export type EventHook<A extends Array<unknown>> = TaskAction<[Event<A>]>;
export type EventExpression = {
    pattern: string;
    regexp: RegExp;
};
export type Body = string | Buffer | Uint8Array | Readable | ReadableStream | Record<string, unknown> | Array<unknown>;
export type ResponseDispatcher<S = unknown> = (res: Response<S>) => Promise<S>;
export type ResponseOptions<S = unknown> = {
    body?: Body;
    headers?: Headers;
    mimetype?: string;
    data?: Data;
    resource?: S;
};
export type Headers = Record<string, string | string[]> | Map<string, string | string[]>;
export type Data = Map<string, any> | NestedObject;
export type Query = string | Map<string, any> | NestedObject;
export type Session = Record<string, string> | Map<string, string>;
export type Post = Record<string, unknown> | Map<string, any>;
export type LoaderResults = {
    body?: Body;
    post?: Post;
};
export type RequestLoader<R = unknown> = (req: Request<R>) => Promise<LoaderResults | undefined>;
export type CallableSession = ((name: string) => string | string[] | undefined) & WriteSession;
export type RequestOptions<R = unknown> = {
    resource: R;
    body?: Body;
    headers?: Headers;
    mimetype?: string;
    data?: Data;
    method?: Method;
    query?: Query;
    post?: Post;
    session?: Session;
    url?: string | URL;
};
export type Revision = {
    action: 'set' | 'remove';
    value?: string | string[];
};
export type Method = 'ALL' | 'CONNECT' | 'DELETE' | 'GET' | 'HEAD' | 'OPTIONS' | 'PATCH' | 'POST' | 'PUT' | 'TRACE';
export type Route = {
    method: string;
    path: string;
};
export type RouteMap<R = unknown, S = unknown> = Record<string, [R, S]>;
export type RouteAction<R = unknown, S = unknown> = TaskAction<[R, S]>;
export type RouterContext<R, S, X> = X extends undefined ? Router<R, S> : X;
export type RouterArgs<R, S, X> = [
    Request<R>,
    Response<S>,
    RouterContext<R, S, X>
];
export type RouterMap<R = unknown, S = unknown, X = undefined> = Record<string, RouterArgs<R, S, X>>;
export type RouterAction<R = unknown, S = unknown, X = undefined> = TaskAction<RouterArgs<R, S, X>>;
export type FileRecursiveOption = {
    recursive?: boolean;
};
export type FileStat = {
    isFile(): boolean;
};
export type FileStream = {
    pipe: (res: ServerResponse<IncomingMessage>) => void;
};
export interface FileSystem {
    exists(path: string): Promise<boolean>;
    readFile(path: string, encoding: BufferEncoding): Promise<string>;
    realpath(string: string): Promise<string>;
    stat(path: string): Promise<FileStat>;
    writeFile(path: string, data: string): Promise<void>;
    mkdir(path: string, options?: FileRecursiveOption): Promise<void>;
    createReadStream(path: string): FileStream;
    unlink(path: string): void;
}
export interface CallSite {
    getThis(): unknown;
    getTypeName(): string;
    getFunction(): Function;
    getFunctionName(): string;
    getMethodName(): string;
    getFileName(): string;
    getLineNumber(): number;
    getColumnNumber(): number;
    getEvalOrigin(): string;
    isToplevel(): boolean;
    isEval(): boolean;
    isNative(): boolean;
    isConstructor(): boolean;
    isAsync(): boolean;
    isPromiseAll(): boolean;
    getPromiseIndex(): number | null;
}
