"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formDataToObject = formDataToObject;
exports.isObject = isObject;
exports.makeArray = makeArray;
exports.makeObject = makeObject;
exports.objectFromArgs = objectFromArgs;
exports.objectFromJson = objectFromJson;
exports.objectFromQuery = objectFromQuery;
exports.objectFromFormData = objectFromFormData;
exports.shouldBeAnArray = shouldBeAnArray;
exports.nest = nest;
const Exception_js_1 = __importDefault(require("../Exception.js"));
const ArgString_js_1 = __importDefault(require("./processors/ArgString.js"));
const PathString_js_1 = __importDefault(require("./processors/PathString.js"));
const QueryString_js_1 = __importDefault(require("./processors/QueryString.js"));
const FormData_js_1 = __importDefault(require("./processors/FormData.js"));
const ReadonlyNest_js_1 = __importDefault(require("./ReadonlyNest.js"));
class Nest extends ReadonlyNest_js_1.default {
    get data() {
        return this._data;
    }
    set data(data) {
        Exception_js_1.default.require((data === null || data === void 0 ? void 0 : data.constructor) === Object, 'Argument 1 expected Object');
        this._data = data;
    }
    constructor(data = {}) {
        super(data);
        this.withArgs = new ArgString_js_1.default(this);
        this.withFormData = new FormData_js_1.default(this);
        this.withPath = new PathString_js_1.default(this);
        this.withQuery = new QueryString_js_1.default(this);
    }
    clear() {
        this._data = {};
        return this;
    }
    delete(...path) {
        if (!path.length) {
            return this;
        }
        if (!this.has(...path)) {
            return this;
        }
        const last = path.pop();
        let pointer = this._data;
        path.forEach(step => {
            pointer = pointer[step];
        });
        delete pointer[last];
        return this;
    }
    set(...path) {
        if (path.length < 1) {
            return this;
        }
        if (typeof path[0] === 'object') {
            Object.keys(path[0]).forEach(key => {
                this.set(key, path[0][key]);
            });
            return this;
        }
        const value = path.pop();
        let last = path.pop(), pointer = this._data;
        path.forEach((step, i) => {
            if (step === null || step === '') {
                path[i] = step = Object.keys(pointer).length;
            }
            if (typeof pointer[step] !== 'object') {
                pointer[step] = {};
            }
            pointer = pointer[step];
        });
        if (last === null || last === '') {
            last = Object.keys(pointer).length;
        }
        pointer[last] = value;
        pointer = this._data;
        path.forEach((step) => {
            const next = pointer[step];
            if (!Array.isArray(next) && shouldBeAnArray(next)) {
                pointer[step] = makeArray(next);
            }
            else if (Array.isArray(next) && !shouldBeAnArray(next)) {
                pointer[step] = makeObject(next);
            }
            pointer = pointer[step];
        });
        return this;
    }
}
exports.default = Nest;
function formDataToObject(type, body) {
    return type.endsWith('/json')
        ? objectFromJson(body)
        : type.endsWith('/x-www-form-urlencoded')
            ? objectFromQuery(body)
            : type.startsWith('multipart/form-data')
                ? objectFromFormData(body)
                : {};
}
;
function isObject(value) {
    var _a;
    return typeof value === 'object' && ((_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'Object';
}
;
function makeArray(object) {
    const array = [];
    const keys = Object.keys(object);
    keys.sort();
    keys.forEach(function (key) {
        array.push(object[key]);
    });
    return array;
}
function makeObject(array) {
    return Object.assign({}, array);
}
function objectFromArgs(args) {
    if (args) {
        const nest = new Nest();
        nest.withArgs.set(args);
        return nest.get();
    }
    return {};
}
function objectFromJson(json) {
    if (json.startsWith('{')) {
        return JSON.parse(json);
    }
    return {};
}
;
function objectFromQuery(query) {
    if (query.startsWith('?')) {
        query = query.substring(1);
    }
    if (query) {
        const nest = new Nest();
        nest.withQuery.set(query);
        return nest.get();
    }
    return {};
}
;
function objectFromFormData(data) {
    if (data) {
        const nest = new Nest();
        nest.withFormData.set(data);
        return nest.get();
    }
    return {};
}
;
function shouldBeAnArray(object) {
    if (!object || typeof object !== 'object') {
        return false;
    }
    const length = Object.keys(object).length;
    if (!length) {
        return false;
    }
    for (let i = 0; i < length; i++) {
        if (typeof object[i] === 'undefined') {
            return false;
        }
    }
    return true;
}
function nest(data) {
    const store = new Nest(data);
    const callable = Object.assign((...path) => store.get(...path), {
        clear: () => store.clear(),
        delete: (...path) => store.delete(...path),
        entries: () => store.entries(),
        forEach: (...path) => store.forEach(...path),
        get: (...path) => store.get(...path),
        has: (...path) => store.has(...path),
        keys: () => store.keys(),
        path: (path, defaults) => store.path(path, defaults),
        set: (...path) => store.set(...path),
        toString: () => store.toString(),
        values: () => store.values(),
        withArgs: store.withArgs,
        withFormData: store.withFormData,
        withPath: store.withPath,
        withQuery: store.withQuery
    });
    Object.defineProperty(callable, 'size', { get: () => store.size });
    Object.defineProperty(callable, 'data', { get: () => store.data });
    return callable;
}
;
