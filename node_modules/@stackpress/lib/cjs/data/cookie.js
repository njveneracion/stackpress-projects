"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = parse;
exports.serialize = serialize;
function parse(serial, options) {
    const results = new NullObject();
    if (serial.length < 2)
        return results;
    const dec = (options === null || options === void 0 ? void 0 : options.decode) || decode;
    let index = 0;
    do {
        const eq = serial.indexOf('=', index);
        if (eq === -1)
            break;
        const colon = serial.indexOf(';', index);
        const end = colon === -1 ? serial.length : colon;
        if (eq > end) {
            index = serial.lastIndexOf(';', eq - 1) + 1;
            continue;
        }
        const keyStart = startIndex(serial, index, eq);
        const keyEnd = endIndex(serial, eq, keyStart);
        const key = serial.slice(keyStart, keyEnd);
        if (results[key] === undefined) {
            let valStartIdx = startIndex(serial, eq + 1, end);
            let valEndIdx = endIndex(serial, end, valStartIdx);
            const value = dec(serial.slice(valStartIdx, valEndIdx));
            results[key] = value;
        }
        index = end + 1;
    } while (index < serial.length);
    return results;
}
;
function serialize(name, val, options) {
    const encode = (options === null || options === void 0 ? void 0 : options.encode) || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = encode(val);
    if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${val}`);
    }
    let serial = name + '=' + value;
    if (!options)
        return serial;
    if (options.maxAge !== undefined) {
        if (!Number.isInteger(options.maxAge)) {
            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
        }
        serial += '; Max-Age=' + options.maxAge;
    }
    if (options.domain) {
        if (!domainValueRegExp.test(options.domain)) {
            throw new TypeError(`option domain is invalid: ${options.domain}`);
        }
        serial += '; Domain=' + options.domain;
    }
    if (options.path) {
        if (!pathValueRegExp.test(options.path)) {
            throw new TypeError(`option path is invalid: ${options.path}`);
        }
        serial += '; Path=' + options.path;
    }
    if (options.expires) {
        if (!isDate(options.expires) ||
            !Number.isFinite(options.expires.valueOf())) {
            throw new TypeError(`option expires is invalid: ${options.expires}`);
        }
        serial += '; Expires=' + options.expires.toUTCString();
    }
    if (options.httpOnly) {
        serial += '; HttpOnly';
    }
    if (options.secure) {
        serial += '; Secure';
    }
    if (options.partitioned) {
        serial += '; Partitioned';
    }
    if (options.priority) {
        const priority = typeof options.priority === 'string'
            ? options.priority.toLowerCase()
            : undefined;
        switch (priority) {
            case 'low':
                serial += '; Priority=Low';
                break;
            case 'medium':
                serial += '; Priority=Medium';
                break;
            case 'high':
                serial += '; Priority=High';
                break;
            default:
                throw new TypeError(`option priority is invalid: ${options.priority}`);
        }
    }
    if (options.sameSite) {
        const sameSite = typeof options.sameSite === 'string'
            ? options.sameSite.toLowerCase()
            : options.sameSite;
        switch (sameSite) {
            case true:
            case 'strict':
                serial += '; SameSite=Strict';
                break;
            case 'lax':
                serial += '; SameSite=Lax';
                break;
            case 'none':
                serial += '; SameSite=None';
                break;
            default:
                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
        }
    }
    return serial;
}
;
const cookie = { parse, serialize };
exports.default = cookie;
const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
const domainValueRegExp = (/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i);
const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
const __toString = Object.prototype.toString;
const NullObject = (() => {
    const C = function () { };
    C.prototype = Object.create(null);
    return C;
})();
function startIndex(serial, index, max) {
    do {
        const code = serial.charCodeAt(index);
        if (code !== 0x20 && code !== 0x09)
            return index;
    } while (++index < max);
    return max;
}
function endIndex(serial, index, min) {
    while (index > min) {
        const code = serial.charCodeAt(--index);
        if (code !== 0x20 && code !== 0x09)
            return index + 1;
    }
    return min;
}
function decode(str) {
    if (str.indexOf('%') === -1)
        return str;
    try {
        return decodeURIComponent(str);
    }
    catch (e) {
        return str;
    }
}
function isDate(val) {
    return __toString.call(val) === '[object Date]';
}
