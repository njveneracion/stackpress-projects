"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Status_js_1 = __importDefault(require("./Status.js"));
class Exception extends Error {
    static for(message, ...values) {
        values.forEach(function (value) {
            message = message.replace('%s', String(value));
        });
        return new this(message);
    }
    static forResponse(response, message = '') {
        const exception = new this(response.error || message, response.code);
        exception.withErrors(response.errors || {});
        return exception;
    }
    static forErrors(errors) {
        const exception = new this('Invalid Parameters');
        exception.withErrors(errors);
        return exception;
    }
    static require(condition, message, ...values) {
        if (!condition) {
            for (const value of values) {
                message = message.replace('%s', value);
            }
            throw new this(message);
        }
    }
    static try(callback) {
        return {
            catch: (catcher) => {
                try {
                    return callback();
                }
                catch (error) {
                    if (error instanceof Exception) {
                        return catcher(error, error.type);
                    }
                    else if (error instanceof Error) {
                        const e = Exception.upgrade(error);
                        return catcher(e, e.type);
                    }
                    else if (typeof error === 'string') {
                        const e = Exception.for(error);
                        return catcher(e, e.type);
                    }
                    return catcher(error, 'unknown');
                }
            }
        };
    }
    static upgrade(error, code = 500) {
        if (error instanceof Exception) {
            return error;
        }
        const exception = new this(error.message, code);
        exception.name = error.name;
        exception.stack = error.stack;
        return exception;
    }
    get code() {
        return this._code;
    }
    get end() {
        return this._end;
    }
    get errors() {
        return Object.assign({}, this._errors);
    }
    get start() {
        return this._start;
    }
    get type() {
        return this._type;
    }
    constructor(message, code = 500) {
        var _a;
        super(message);
        this._errors = {};
        this._start = 0;
        this._end = 0;
        this.name = this.constructor.name;
        this._type = this.constructor.name;
        this._code = code;
        this._status = ((_a = Status_js_1.default.get(code)) === null || _a === void 0 ? void 0 : _a.status) || 'Unknown';
    }
    toJSON() {
        return JSON.stringify(this.toResponse(), null, 2);
    }
    toResponse(start = 0, end = 0) {
        const json = {
            code: this._code,
            status: this._status,
            error: this.message,
            start: this._start,
            end: this._end,
            stack: this.trace(start, end)
        };
        if (Object.keys(this._errors).length > 0) {
            json.errors = this._errors;
        }
        return json;
    }
    trace(start = 0, end = 0) {
        if (typeof this.stack !== 'string') {
            return [];
        }
        const trace = this.stack
            .split('\n')
            .slice(start, end || this.stack.length)
            .map(line => line.trim())
            .map(trace => {
            if (!trace.startsWith('at')) {
                return false;
            }
            let [_, method, location] = trace.split(' ');
            if (!location) {
                location = `(${method})`;
                method = '<none>';
            }
            const [file, line, char] = location
                .substring(1, location.length - 1)
                .split(':');
            return {
                method,
                file,
                line: parseInt(line) || 0,
                char: parseInt(char) || 0
            };
        })
            .filter(Boolean);
        return trace;
    }
    withCode(code) {
        var _a;
        this._code = code;
        this._status = ((_a = Status_js_1.default.get(code)) === null || _a === void 0 ? void 0 : _a.status) || 'Unknown';
        return this;
    }
    withErrors(errors) {
        this._errors = errors;
        return this;
    }
    withPosition(start, end) {
        this._start = start;
        this._end = end;
        return this;
    }
}
exports.default = Exception;
