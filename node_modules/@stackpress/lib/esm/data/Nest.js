import Exception from '../Exception.js';
import ArgString from './processors/ArgString.js';
import PathString from './processors/PathString.js';
import QueryString from './processors/QueryString.js';
import FormData from './processors/FormData.js';
import ReadonlyNest from './ReadonlyNest.js';
export default class Nest extends ReadonlyNest {
    withArgs;
    withFormData;
    withPath;
    withQuery;
    get data() {
        return this._data;
    }
    set data(data) {
        Exception.require(data?.constructor === Object, 'Argument 1 expected Object');
        this._data = data;
    }
    constructor(data = {}) {
        super(data);
        this.withArgs = new ArgString(this);
        this.withFormData = new FormData(this);
        this.withPath = new PathString(this);
        this.withQuery = new QueryString(this);
    }
    clear() {
        this._data = {};
        return this;
    }
    delete(...path) {
        if (!path.length) {
            return this;
        }
        if (!this.has(...path)) {
            return this;
        }
        const last = path.pop();
        let pointer = this._data;
        path.forEach(step => {
            pointer = pointer[step];
        });
        delete pointer[last];
        return this;
    }
    set(...path) {
        if (path.length < 1) {
            return this;
        }
        if (typeof path[0] === 'object') {
            Object.keys(path[0]).forEach(key => {
                this.set(key, path[0][key]);
            });
            return this;
        }
        const value = path.pop();
        let last = path.pop(), pointer = this._data;
        path.forEach((step, i) => {
            if (step === null || step === '') {
                path[i] = step = Object.keys(pointer).length;
            }
            if (typeof pointer[step] !== 'object') {
                pointer[step] = {};
            }
            pointer = pointer[step];
        });
        if (last === null || last === '') {
            last = Object.keys(pointer).length;
        }
        pointer[last] = value;
        pointer = this._data;
        path.forEach((step) => {
            const next = pointer[step];
            if (!Array.isArray(next) && shouldBeAnArray(next)) {
                pointer[step] = makeArray(next);
            }
            else if (Array.isArray(next) && !shouldBeAnArray(next)) {
                pointer[step] = makeObject(next);
            }
            pointer = pointer[step];
        });
        return this;
    }
}
export function formDataToObject(type, body) {
    return type.endsWith('/json')
        ? objectFromJson(body)
        : type.endsWith('/x-www-form-urlencoded')
            ? objectFromQuery(body)
            : type.startsWith('multipart/form-data')
                ? objectFromFormData(body)
                : {};
}
;
export function isObject(value) {
    return typeof value === 'object' && value?.constructor?.name === 'Object';
}
;
export function makeArray(object) {
    const array = [];
    const keys = Object.keys(object);
    keys.sort();
    keys.forEach(function (key) {
        array.push(object[key]);
    });
    return array;
}
export function makeObject(array) {
    return Object.assign({}, array);
}
export function objectFromArgs(args) {
    if (args) {
        const nest = new Nest();
        nest.withArgs.set(args);
        return nest.get();
    }
    return {};
}
export function objectFromJson(json) {
    if (json.startsWith('{')) {
        return JSON.parse(json);
    }
    return {};
}
;
export function objectFromQuery(query) {
    if (query.startsWith('?')) {
        query = query.substring(1);
    }
    if (query) {
        const nest = new Nest();
        nest.withQuery.set(query);
        return nest.get();
    }
    return {};
}
;
export function objectFromFormData(data) {
    if (data) {
        const nest = new Nest();
        nest.withFormData.set(data);
        return nest.get();
    }
    return {};
}
;
export function shouldBeAnArray(object) {
    if (!object || typeof object !== 'object') {
        return false;
    }
    const length = Object.keys(object).length;
    if (!length) {
        return false;
    }
    for (let i = 0; i < length; i++) {
        if (typeof object[i] === 'undefined') {
            return false;
        }
    }
    return true;
}
export function nest(data) {
    const store = new Nest(data);
    const callable = Object.assign((...path) => store.get(...path), {
        clear: () => store.clear(),
        delete: (...path) => store.delete(...path),
        entries: () => store.entries(),
        forEach: (...path) => store.forEach(...path),
        get: (...path) => store.get(...path),
        has: (...path) => store.has(...path),
        keys: () => store.keys(),
        path: (path, defaults) => store.path(path, defaults),
        set: (...path) => store.set(...path),
        toString: () => store.toString(),
        values: () => store.values(),
        withArgs: store.withArgs,
        withFormData: store.withFormData,
        withPath: store.withPath,
        withQuery: store.withQuery
    });
    Object.defineProperty(callable, 'size', { get: () => store.size });
    Object.defineProperty(callable, 'data', { get: () => store.data });
    return callable;
}
;
