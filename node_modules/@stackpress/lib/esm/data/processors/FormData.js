import Exception from '../../Exception.js';
import FileData from './FileData.js';
export default class FormData {
    nest;
    constructor(nest) {
        this.nest = nest;
    }
    set(...path) {
        if (path.length < 1) {
            return this.nest;
        }
        const formData = path.pop();
        const formDataBuffer = typeof formData === 'string'
            ? Buffer.from(formData)
            : formData;
        const boundary = this._getBoundary(formDataBuffer);
        if (!boundary) {
            throw Exception.for('Invalid form data');
        }
        let part = [];
        for (let i = 0; i < formDataBuffer.length; i++) {
            const line = this._getLine(formDataBuffer, i);
            if (line === null) {
                break;
            }
            const buffer = line.buffer;
            if (buffer.toString().indexOf(boundary) === 0) {
                if (part.length) {
                    this._setPart(path, this._getPart(part));
                }
                if (buffer.toString() === `${boundary}--`) {
                    break;
                }
                part = [];
            }
            else {
                part.push(buffer);
            }
            i = line.i;
        }
        return this.nest;
    }
    _getBoundary(buffer) {
        const boundary = this._getLine(buffer, 0)?.buffer;
        if (!boundary) {
            return null;
        }
        return boundary.subarray(0, boundary.length - 1).toString();
    }
    _getLine(buffer, i) {
        const line = [];
        for (; i < buffer.length; i++) {
            const current = buffer[i];
            line.push(current);
            if (current === 0x0a || current === 0x0d) {
                return { i, buffer: Buffer.from(line) };
            }
        }
        if (line.length) {
            return { i, buffer: Buffer.from(line) };
        }
        return null;
    }
    _getPart(lines) {
        const headerLines = [];
        do {
            headerLines.push(lines.shift()?.toString());
        } while (lines.length
            && !(lines[0].length === 1
                && (lines[0][0] === 0x0a
                    || lines[0][0] === 0x0d)));
        const last = lines[lines.length - 1];
        lines[lines.length - 1] = last.slice(0, last.length - 1);
        const body = Buffer.concat(lines.slice(1));
        const headers = {};
        for (const line of headerLines) {
            if (line && line.indexOf(':') !== -1) {
                const [key, value] = line.toString().split(':', 2);
                headers[key.trim().toLowerCase()] = value.trim();
            }
        }
        const form = {};
        if (typeof headers['content-disposition'] === 'string') {
            headers['content-disposition'].split(';').forEach(disposition => {
                const matches = disposition
                    .trim()
                    .match(/^([a-zA-Z0-9_\-]+)=["']([^"']+)["']$/);
                if (matches && matches.length > 2) {
                    form[matches[1]] = matches[2];
                }
            });
        }
        return { headers, body, form };
    }
    _setPart(path, part) {
        if (!part.form.name) {
            return this;
        }
        const separator = '~~' + Math.floor(Math.random() * 10000) + '~~';
        const keys = part.form.name
            .replace(/\]\[/g, separator)
            .replace('[', separator)
            .replace(/\[/g, '')
            .replace(/\]/g, '')
            .split(separator)
            .map((key) => {
            const index = Number(key);
            if (key && !isNaN(index) && key.indexOf('.') === -1) {
                return index;
            }
            return key;
        });
        const paths = path.concat(keys);
        if (!part.form.filename) {
            const value = part.body
                .toString()
                .replace(/^\r\n/, '')
                .replace(/\r\n$/, '')
                .replace(/\r$/, '');
            if (/(^\{.*\}$)|(^\[.*\]$)/.test(value)) {
                try {
                    return this.nest.set(...paths, JSON.parse(value));
                }
                catch (e) { }
            }
            if (value.length > 0 && !isNaN(Number(value))) {
                this.nest.set(...paths, Number(value));
            }
            else if (value === 'true') {
                this.nest.set(...paths, true);
            }
            else if (value === 'false') {
                this.nest.set(...paths, false);
            }
            else if (value === 'null') {
                this.nest.set(...paths, null);
            }
            else {
                this.nest.set(...paths, value);
            }
            return this;
        }
        this.nest.set(...paths, new FileData({
            data: part.body,
            name: part.form.filename,
            type: part.headers['content-type']
        }));
    }
}
