import EventEmitter from './EventEmitter.js';
export const VARIABLE_NAME = /(\:[a-zA-Z0-9\-_]+)/g;
export const EVENT_PATTERNS = /(\:[a-zA-Z0-9\-_]+)|(\*\*)|(\*)/g;
export default class ExpressEmitter extends EventEmitter {
    separator;
    expressions = new Map();
    constructor(separator = '/') {
        super();
        this.separator = separator;
    }
    match(event) {
        const matches = super.match(event);
        this.expressions.forEach((expression, key) => {
            const match = this._match(event, expression);
            if (match) {
                matches.set(key, match);
            }
        });
        return matches;
    }
    on(event, action, priority = 0) {
        event = this._eventName(event);
        return this._listen(event, action, priority);
    }
    use(emitter) {
        if (emitter instanceof ExpressEmitter) {
            emitter.expressions.forEach((expression, event) => this.expressions.set(event, expression));
        }
        super.use(emitter);
        return this;
    }
    _eventName(event) {
        if (event instanceof RegExp) {
            return this._eventNameFromRegExp(event, '');
        }
        else {
            const fragment = this._toFragment(event);
            if (fragment !== event) {
                return this._eventNameFromExpression(`^${fragment}$`, event);
            }
        }
        return event;
    }
    _eventNameFromExpression(expression, pattern) {
        const regexp = new RegExp(expression, 'g');
        const event = regexp.toString();
        this.expressions.set(event, { pattern, regexp });
        return event;
    }
    _eventNameFromRegExp(regexp, pattern) {
        const event = regexp.toString();
        this.expressions.set(event, { pattern, regexp });
        return event;
    }
    _listen(event, action, priority = 0) {
        return super.on(event, action, priority);
    }
    _match(event, expression) {
        const { pattern, regexp } = expression;
        const data = { args: [], params: {} };
        if (regexp.flags.indexOf('g') === -1) {
            const match = event.match(regexp);
            if (!match || !match.length) {
                return null;
            }
            if (Array.isArray(match)) {
                data.args = match.slice();
                data.args.shift();
            }
        }
        else {
            const match = Array.from(event.matchAll(regexp));
            if (!Array.isArray(match[0]) || !match[0].length) {
                return null;
            }
            data.args = match[0].slice();
            data.args.shift();
        }
        if (pattern.length === 0) {
            return { event, pattern: regexp.toString(), data };
        }
        const map = Array.from(pattern.matchAll(EVENT_PATTERNS)).map(match => match[0]);
        const args = data.args;
        data.args = [];
        args.forEach((param, i) => {
            if (typeof map[i] !== 'string'
                || map[i].indexOf('*') === 0) {
                if (param.indexOf('/') === -1) {
                    return data.args.push(param);
                }
                return Array.prototype.push.apply(data.args, param.split('/'));
            }
            if (typeof map[i] === 'string') {
                data.params[map[i].substring(1)] = param;
            }
        });
        return { event, pattern, data };
    }
    _toFragment(pattern) {
        const sep = `[^${this.separator}]+`;
        return pattern
            .replace(VARIABLE_NAME, '*')
            .replaceAll('*', `(${sep})`)
            .replaceAll(`(${sep})(${sep})`, '(.*)');
    }
}
