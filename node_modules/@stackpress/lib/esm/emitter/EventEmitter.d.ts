import type { TaskAction, TaskItem, Event, EventMap, EventName, EventHook, EventMatch } from '../types.js';
import TaskQueue from '../queue/TaskQueue.js';
export default class EventEmitter<M extends EventMap> {
    protected _after?: EventHook<M[keyof M]>;
    protected _before?: EventHook<M[keyof M]>;
    protected _event?: Event<M[keyof M]>;
    protected _listeners: {
        [K in keyof M]?: Set<TaskItem<M[K]>>;
    };
    set after(action: EventHook<M[keyof M]>);
    set before(action: EventHook<M[keyof M]>);
    get event(): Event<M[keyof M]> | undefined;
    get listeners(): Readonly<{ [K in keyof M]?: Set<TaskItem<M[K]>> | undefined; }>;
    clear<N extends EventName<M>>(event: N): this;
    emit<N extends EventName<M>>(event: N, ...args: M[N]): Promise<import("../types.js").ResponseStatus>;
    makeQueue<A extends Array<unknown>>(): TaskQueue<A>;
    match(event: string): Map<string, EventMatch>;
    on<N extends EventName<M>>(event: N, action: TaskAction<M[N]>, priority?: number): this;
    tasks<N extends EventName<M>>(event: N): TaskQueue<M[keyof M]>;
    unbind<N extends EventName<M>>(event: N, action: TaskAction<M[N]>): this;
    use(emitter: EventEmitter<M>): this;
    protected _task(match: EventMatch, task: TaskItem<M[keyof M]>): (...args: M[keyof M]) => Promise<false | undefined>;
}
