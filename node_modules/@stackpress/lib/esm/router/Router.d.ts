import type { Route, RouterMap, RouterArgs, RouterAction, RouterContext, RequestOptions, ResponseOptions, StatusResponse, EventMatch, TaskItem } from '../types.js';
import type EventEmitter from '../emitter/EventEmitter.js';
import ExpressEmitter from '../emitter/ExpressEmitter.js';
import Request from './Request.js';
import Response from './Response.js';
export default class Router<R = unknown, S = unknown, X = undefined> extends ExpressEmitter<RouterMap<R, S, X>> {
    readonly routes: Map<string, Route>;
    constructor();
    emit(event: string, req: Request<R>, res: Response<S>): Promise<import("../types.js").ResponseStatus>;
    resolve<T = unknown>(event: string, request?: Request<R> | Record<string, any>, response?: Response<S>): Promise<Partial<StatusResponse<T>>>;
    resolve<T = unknown>(method: string, path: string, request?: Request<R> | Record<string, any>, response?: Response<S>): Promise<Partial<StatusResponse<T>>>;
    request(init?: Partial<RequestOptions<R>>): Request<R>;
    response(init?: Partial<ResponseOptions<S>>): Response<S>;
    route(method: string, path: string, action: RouterAction<R, S, X>, priority?: number): this;
    use(emitter: EventEmitter<RouterMap<R, S, X>>): this;
    protected _eventNameFromRoute(method: string, path: string): string;
    protected _resolveEvent<T = unknown>(event: string, request?: Request<R> | Record<string, any>, response?: Response<S>): Promise<Partial<Partial<import("../types.js").ResponseStatus & {
        error: string;
        errors?: import("../types.js").NestedObject<string | string[]>;
        start?: number;
        end?: number;
        stack?: import("../types.js").Trace[];
    } & {
        results: T;
        total?: number;
    }>>>;
    protected _resolveRoute<T = unknown>(method: string, path: string, request?: Request<R> | Record<string, any>, response?: Response<S>): Promise<Partial<Partial<import("../types.js").ResponseStatus & {
        error: string;
        errors?: import("../types.js").NestedObject<string | string[]>;
        start?: number;
        end?: number;
        stack?: import("../types.js").Trace[];
    } & {
        results: T;
        total?: number;
    }>>>;
    protected _task(match: EventMatch, task: TaskItem<RouterArgs<R, S, X>>): (req: Request<R>, res: Response<S>, ctx: RouterContext<R, S, X>) => Promise<false | undefined>;
}
