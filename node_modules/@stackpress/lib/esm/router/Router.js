import Status from '../Status.js';
import { isObject } from '../data/Nest.js';
import ExpressEmitter from '../emitter/ExpressEmitter.js';
import Request from './Request.js';
import Response from './Response.js';
export default class Router extends ExpressEmitter {
    routes = new Map;
    constructor() {
        super('/');
    }
    async emit(event, req, res) {
        const queue = this.tasks(event);
        if (queue.size === 0) {
            return Status.NOT_FOUND;
        }
        return await queue.run(req, res, this);
    }
    async resolve(methodPath, pathRequest, requestResponse, response) {
        if (typeof pathRequest === 'string') {
            return this._resolveRoute(methodPath, pathRequest, requestResponse, response);
        }
        return this._resolveEvent(methodPath, pathRequest, requestResponse);
    }
    request(init = {}) {
        return new Request(init);
    }
    response(init = {}) {
        return new Response(init);
    }
    route(method, path, action, priority = 0) {
        const event = this._eventNameFromRoute(method, path);
        this._listen(event, action, priority);
        return this;
    }
    use(emitter) {
        if (emitter instanceof Router) {
            emitter.routes.forEach((route, event) => this.routes.set(event, route));
        }
        super.use(emitter);
        return this;
    }
    _eventNameFromRoute(method, path) {
        method = method.toUpperCase();
        const fragment = this._toFragment(path);
        if (method === 'ANY') {
            const pattern = fragment !== path ? path : '';
            const expression = `^[A-Z]+ ${fragment}${this.separator}*$`;
            const event = this._eventNameFromExpression(expression, pattern);
            this.routes.set(event, { method, path });
            return event;
        }
        let event = `${method} ${path}`;
        if (fragment !== path) {
            const expression = `^${method} ${fragment}${this.separator}*$`;
            event = this._eventNameFromExpression(expression, event);
            this.routes.set(event, { method, path });
            return event;
        }
        this.routes.set(event, { method, path });
        return event;
    }
    async _resolveEvent(event, request, response) {
        if (!request) {
            request = this.request();
        }
        else if (isObject(request)) {
            const data = request;
            request = this.request({ data });
        }
        const req = request;
        const res = response || this.response();
        await this.emit(event, req, res);
        return res.toStatusResponse();
    }
    async _resolveRoute(method, path, request, response) {
        const event = `${method.toUpperCase()} ${path}`;
        return await this._resolveEvent(event, request, response);
    }
    _task(match, task) {
        return async (req, res, ctx) => {
            this._event = {
                ...match,
                ...task,
                args: [req, res, ctx],
                action: task.item
            };
            req.data.set(match.data.params);
            if (match.data.args.length) {
                req.data.set(match.data.args);
            }
            if (typeof this._before === 'function'
                && await this._before(this._event) === false) {
                return false;
            }
            if (await task.item(req, res, ctx) === false) {
                return false;
            }
            if (typeof this._after === 'function'
                && await this._after(this._event) === false) {
                return false;
            }
        };
    }
}
;
