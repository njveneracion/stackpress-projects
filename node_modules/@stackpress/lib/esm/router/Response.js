import Status from '../Status.js';
import Exception from '../Exception.js';
import map from '../data/map.js';
import { nest, isObject } from '../data/Nest.js';
import { session } from './Session.js';
export default class Response {
    headers;
    session;
    errors;
    data;
    _body;
    _code = 0;
    _dispatcher;
    _error;
    _mimetype;
    _resource;
    _sent = false;
    _stack;
    _status = '';
    _total = 0;
    get body() {
        return typeof this._body !== 'undefined' ? this._body : null;
    }
    get code() {
        return this._code;
    }
    get error() {
        return this._error;
    }
    get redirected() {
        return this.headers.has('Location');
    }
    get sent() {
        return this._sent;
    }
    get stack() {
        return this._stack;
    }
    get status() {
        return this._status;
    }
    get total() {
        return this._total;
    }
    get mimetype() {
        return this._mimetype;
    }
    get resource() {
        return this._resource;
    }
    get type() {
        if (this._body instanceof Buffer) {
            return 'buffer';
        }
        else if (this._body instanceof Uint8Array) {
            return 'uint8array';
        }
        else if (isObject(this._body)) {
            return 'object';
        }
        else if (Array.isArray(this._body)) {
            return 'array';
        }
        else if (typeof this._body === 'string') {
            return 'string';
        }
        else if (this._body === null) {
            return 'null';
        }
        return typeof this._body;
    }
    set body(value) {
        this._body = value;
    }
    set code(code) {
        this._code = code;
        this._status = Status.get(code)?.status || '';
    }
    set dispatcher(dispatcher) {
        this._dispatcher = dispatcher;
    }
    set error(error) {
        this._error = error;
    }
    set resource(resource) {
        this._resource = resource;
    }
    set stack(stack) {
        this._stack = stack;
    }
    set status(status) {
        this._code = status.code;
        this._status = status.status;
    }
    set total(total) {
        this._total = total;
    }
    set mimetype(value) {
        this._mimetype = value;
    }
    constructor(init = {}) {
        this._mimetype = init.mimetype;
        this._body = init.body || null;
        this._resource = init.resource;
        this.errors = nest();
        this.session = session();
        this.headers = map(init.headers instanceof Map
            ? Array.from(init.headers.entries())
            : isObject(init.headers)
                ? Object.entries(init.headers)
                : undefined);
        this.data = nest();
        if (init.data instanceof Map) {
            this.data.set(Object.fromEntries(init.data));
        }
        else if (isObject(init.data)) {
            this.data.set(init.data);
        }
    }
    async dispatch() {
        if (!this._sent) {
            const resource = typeof this._dispatcher === 'function'
                ? await this._dispatcher(this)
                : this.resource;
            this._sent = true;
            return resource;
        }
        return this.resource;
    }
    fromStatusResponse(response) {
        const { code, status, error, errors, stack, results, total } = response;
        if (code) {
            this._code = code;
        }
        if (status) {
            this._status = status;
        }
        else if (this._code) {
            this._status = Status.get(this._code)?.status || 'Unknown Status';
        }
        if (error) {
            this._error = error;
        }
        if (errors) {
            this.errors.set(errors);
        }
        if (stack) {
            this._stack = stack;
        }
        if (results) {
            if (isObject(results) || Array.isArray(results)) {
                this._mimetype = 'application/json';
            }
            this._body = results;
        }
        if (total) {
            this._total = total;
        }
        return this;
    }
    redirect(url, code = 302, status) {
        this.setStatus(code, status);
        this.headers.set('Location', url);
        return this;
    }
    setBody(type, body, code = 200, status) {
        this.setStatus(code, status);
        this._mimetype = type;
        this._body = body;
        return this;
    }
    setError(error, errors = {}, stack = [], code = 400, status) {
        if (typeof error !== 'string') {
            errors = error.errors || errors;
            stack = error.stack || stack;
            code = error.code || code;
            status = error.status || status;
            error = error.error;
        }
        this.setStatus(code, status);
        this._error = error;
        this._stack = stack && stack.length > 0 ? stack : undefined;
        this.errors.set(errors);
        return this;
    }
    setHTML(body, code = 200, status) {
        return this.setBody('text/html', body, code, status);
    }
    setJSON(body, code = 200, status) {
        if (typeof body !== 'string') {
            body = JSON.stringify(body, null, 2);
        }
        return this.setBody('application/json', body, code, status);
    }
    setResults(body, code = 200, status) {
        this._total = 1;
        return this.setBody('application/json', body, code, status);
    }
    setRows(body, total = 0, code = 200, status) {
        this._total = total;
        return this.setBody('application/json', body, code, status);
    }
    setStatus(code, message) {
        this._code = code;
        this._status = message || Status.get(code)?.status || '';
        return this;
    }
    setXML(body, code = 200, status) {
        return this.setBody('text/xml', body, code, status);
    }
    stop() {
        this._sent = true;
        return this;
    }
    toException(message) {
        const error = message || this._error || 'Unknown Error';
        const exception = Exception.for(error)
            .withCode(this._code)
            .withErrors(this.errors());
        if (this._stack) {
            let stack = `Response: ${error}\n`;
            stack += this._stack.map(trace => `  at ${trace.method} (`
                + `${trace.file}:${trace.line}:${trace.char}`
                + `)`).join('\n');
            exception.stack = stack;
        }
        return exception;
    }
    toStatusResponse() {
        return {
            code: this._code,
            status: this._status,
            error: this._error,
            errors: this.errors(),
            stack: this._stack,
            results: this._body,
            total: this._total
        };
    }
}
