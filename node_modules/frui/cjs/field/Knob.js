"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Knob;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
function clamp(val, min, max) {
    return Math.min(Math.max(val, min), max);
}
function getAngle(x, y, cx, cy) {
    return Math.atan2(y - cy, x - cx);
}
function formatValue(template, value) {
    return template.replace('{}', value.toString());
}
function Knob({ value, defaultValue = 0, onChange, name = 'knob', min = 0, max = 100, step = 1, valueTemplate = '{}', stroke = 10, size = 100, textColor = '#000', rangeColor = '#eee', valueColor = '#007bff', }) {
    const radius = size / 2;
    const knobRef = (0, react_1.useRef)(null);
    const [internalValue, setInternalValue] = (0, react_1.useState)(defaultValue);
    const [dragging, setDragging] = (0, react_1.useState)(false);
    const actualValue = value !== undefined ? value : internalValue;
    const arcLength = 180;
    const percent = (clamp(actualValue, min, max) - min) / (max - min);
    const circumference = Math.PI * (size - stroke);
    const halfCirc = circumference / 2;
    const offset = halfCirc * (1 - percent);
    const updateValue = (val) => {
        if (onChange) {
            onChange(val);
        }
        else {
            setInternalValue(val);
        }
    };
    const handleInteraction = (clientX, clientY) => {
        var _a;
        const rect = (_a = knobRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
        if (!rect)
            return;
        const cx = rect.left + radius;
        const cy = rect.top + radius;
        const angle = getAngle(clientX, clientY, cx, cy);
        const deg = (angle * 180) / Math.PI + 180;
        if (deg < 0 || deg > 180)
            return;
        const norm = clamp((deg - 0) / arcLength, 0, 1);
        const rawVal = min + norm * (max - min);
        const newVal = Math.round(rawVal / step) * step;
        updateValue(clamp(newVal, min, max));
    };
    (0, react_1.useEffect)(() => {
        const move = (e) => {
            if (dragging) {
                handleInteraction(e.clientX, e.clientY);
            }
        };
        const up = () => setDragging(false);
        document.addEventListener('pointermove', move);
        document.addEventListener('pointerup', up);
        return () => {
            document.removeEventListener('pointermove', move);
            document.removeEventListener('pointerup', up);
        };
    }, [dragging]);
    return ((0, jsx_runtime_1.jsxs)("div", { className: "frui-field-knob", style: { width: size, height: size / 2 }, children: [(0, jsx_runtime_1.jsxs)("svg", { ref: knobRef, width: size, height: size, viewBox: `0 0 ${size} ${size}`, onPointerDown: (e) => {
                    e.preventDefault();
                    setDragging(true);
                    handleInteraction(e.clientX, e.clientY);
                }, className: "frui-field-knob-svg", children: [(0, jsx_runtime_1.jsx)("circle", { cx: radius, cy: radius, r: radius - stroke / 2, stroke: rangeColor, strokeWidth: stroke, fill: "none", strokeDasharray: `${halfCirc} ${circumference}`, strokeDashoffset: 0, strokeLinecap: "round", transform: `rotate(180, ${radius}, ${radius})` }), (0, jsx_runtime_1.jsx)("circle", { cx: radius, cy: radius, r: radius - stroke / 2, stroke: valueColor, strokeWidth: stroke, fill: "none", strokeDasharray: `${halfCirc} ${circumference}`, strokeDashoffset: offset, strokeLinecap: "round", style: { transition: 'stroke-dashoffset 0.1s linear' }, transform: `rotate(180, ${radius}, ${radius})` }), (0, jsx_runtime_1.jsx)("text", { x: "50%", y: "40%", textAnchor: "middle", dominantBaseline: "middle", fontSize: size * 0.2, fill: textColor, className: "frui-field-knob-label", children: formatValue(valueTemplate, actualValue) })] }), (0, jsx_runtime_1.jsx)("input", { type: "hidden", name: name, value: actualValue })] }));
}
