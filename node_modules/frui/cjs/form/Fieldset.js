"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFieldset = useFieldset;
exports.default = make;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const Button_js_1 = __importDefault(require("./Button.js"));
function useFieldset(config) {
    const { value, defaultValue, emptyValue, onChange, onUpdate } = config;
    const safeValues = Array.isArray(defaultValue) ? [...defaultValue] : [];
    const [values, setValues] = (0, react_1.useState)(safeValues);
    const handlers = {
        set: (newValues) => {
            const serial = JSON.stringify(newValues);
            if (serial !== JSON.stringify(values)) {
                const final = JSON
                    .parse(serial)
                    .map((value) => value === null ? undefined : value);
                const clean = final
                    .filter((value) => typeof value !== 'undefined');
                setValues(final);
                onChange && onChange(clean);
                onUpdate && onUpdate(clean);
            }
        },
        add: () => handlers.set(values.concat([emptyValue]))
    };
    (0, react_1.useEffect)(() => {
        if (!Array.isArray(value))
            return;
        handlers.set([...value]);
    }, [value]);
    return { values, handlers };
}
;
function make(Fields) {
    return function Fieldset(props) {
        const { name, add, config, value, limit = 0, defaultValue, emptyValue, error, onChange, onUpdate } = props, attributes = __rest(props, ["name", "add", "config", "value", "limit", "defaultValue", "emptyValue", "error", "onChange", "onUpdate"]);
        const { values, handlers } = useFieldset({
            value,
            defaultValue,
            emptyValue,
            onChange,
            onUpdate
        });
        const size = values.filter(value => typeof value !== 'undefined').length;
        return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [values.map((value, index) => (typeof value !== 'undefined' ? ((0, jsx_runtime_1.jsx)(Fields, { name: name, config: config, index: index, values: values, limit: limit, error: error, set: handlers.set }, index)) : null)), (!limit || size < limit) && ((0, jsx_runtime_1.jsxs)(Button_js_1.default, Object.assign({ muted: true }, attributes, { onClick: handlers.add, type: "button", children: [(0, jsx_runtime_1.jsx)("span", { className: "frui-fieldset-add", children: "+" }), add || 'Add'] })))] }));
    };
}
;
