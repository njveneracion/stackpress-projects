import fs from 'node:fs/promises';
import path from 'node:path';
import Exception from './Exception.js';
import Document from './Document.js';
import { writeFile } from './helpers.js';
export default class ServerManifest {
    documents = new Map();
    _server;
    get size() {
        return this.documents.size;
    }
    constructor(server) {
        this._server = server;
    }
    async set(entry) {
        entry = await this._toEntryPath(entry);
        if (!(await this.has(entry))) {
            const document = new Document(entry, this._server);
            this.documents.set(entry, document);
        }
        return (await this.get(entry));
    }
    entries() {
        return this.map((document, index) => [document, index]);
    }
    find(id) {
        return this.values().find(document => document.id === id) ?? null;
    }
    forEach(callback) {
        this.values().forEach(callback);
    }
    async get(entry) {
        entry = await this._toEntryPath(entry);
        return this.values().find(document => document.entry === entry) ?? null;
    }
    async has(entry) {
        entry = await this._toEntryPath(entry);
        return (await this.get(entry)) !== null;
    }
    load(hash) {
        for (const entry of Object.values(hash)) {
            this.set(entry);
        }
        return this;
    }
    map(callback) {
        return this.values().map(callback);
    }
    async open(file) {
        const json = await fs.readFile(file, 'utf8');
        const hash = JSON.parse(json);
        return this.load(hash);
    }
    async save(file) {
        const hash = this.toJSON();
        const json = JSON.stringify(hash, null, 2);
        await writeFile(file, json);
        return this;
    }
    toJSON() {
        return Object.fromEntries(this.values().map(document => [document.id, document.entry]));
    }
    values() {
        return Array.from(this.documents.values());
    }
    async _toEntryPath(entry) {
        const original = entry;
        const moduleIndex = entry.lastIndexOf('node_modules/');
        if (moduleIndex >= 0) {
            entry = entry.substring(moduleIndex + 13);
        }
        if (!entry.startsWith(path.sep)
            && !entry.startsWith(`.${path.sep}`)
            && !entry.startsWith(`..${path.sep}`)) {
            return entry;
        }
        if (entry.startsWith('file://')) {
            entry = entry.slice(7);
        }
        if (entry.startsWith(`@${path.sep}`)) {
            return entry;
        }
        const loader = this._server.loader;
        entry = await loader.absolute(entry);
        if (entry.startsWith(loader.cwd)) {
            return entry.replace(loader.cwd, '@');
        }
        throw new Exception(`Invalid entry file: ${original}`);
    }
}
