export type { BuildStatus, BuildResults, DocumentImport, DocumentIterator, IM, SR, Next, ViteConfig, DevelopConfig, BuildConfig, ProductionConfig, ServerConfig } from './types.js';
export { VFS_PROTOCOL, VFS_RESOLVED, BASE62_ALPHABET, HASH_LENGTH, DOCUMENT_TEMPLATE, PAGE_TEMPLATE, CLIENT_TEMPLATE } from './constants.js';
export { id, renderJSX, writeFile } from './helpers.js';
export { css, file, hmr, vfs } from './plugins.js';
import FileLoader from '@stackpress/lib/FileLoader';
import NodeFS from '@stackpress/lib/NodeFS';
import DocumentBuilder from './DocumentBuilder.js';
import DocumentLoader from './DocumentLoader.js';
import DocumentRender from './DocumentRender.js';
import ServerLoader from './ServerLoader.js';
import ServerManifest from './ServerManifest.js';
import ServerResource from './ServerResource.js';
import VirtualServer from './VirtualServer.js';
import Builder from './Builder.js';
import Document from './Document.js';
import Server from './Server.js';
import Exception from './Exception.js';
export { DocumentBuilder, DocumentLoader, DocumentRender, ServerLoader, ServerManifest, ServerResource, VirtualServer, Builder, Document, Server, Exception, FileLoader, NodeFS };
import type { UnknownNest } from '@stackpress/lib/types';
import type { IM, SR, ViteConfig, DevelopConfig, BuildConfig, ProductionConfig, ServerConfig, BuildResults, DocumentIterator } from './types.js';
export declare function dev(options: Partial<DevelopConfig>): {
    config: Readonly<{
        assetPath: string;
        basePath: string;
        clientPath: string;
        clientRoute: string;
        clientTemplate: string;
        cssFiles: string[] | undefined;
        cssRoute: string;
        cwd: string;
        documentTemplate: string;
        fs: import("@stackpress/lib/types").FileSystem | NodeFS;
        optimizeDeps: import("vite").DepOptimizationOptions | undefined;
        pagePath: string;
        pageTemplate: string;
        plugins: import("vite").PluginOption[];
        production: boolean;
        vite: import("vite").InlineConfig | undefined;
        watchIgnore: string[];
    }>;
    paths: Readonly<{
        asset: string;
        client: string;
        css?: string[];
        head?: string;
        page: string;
    }>;
    routes: Readonly<{
        client: string;
        css: string;
    }>;
    templates: Readonly<{
        client: string;
        document: string;
        page: string;
    }>;
    viteConfig: Readonly<import("vite").InlineConfig> | null;
    readonly size: number;
    server: Server;
    dev: () => Promise<import("vite").ViteDevServer>;
    http: (req: IM, res: SR) => Promise<unknown>;
    middlewares: () => Promise<import("vite").Connect.Server>;
    plugins: () => Promise<import("vite").PluginOption[]>;
    entries: () => [Document, number][];
    find: (id: string) => Document | null;
    forEach: (callback: DocumentIterator<unknown>) => void;
    get: (entry: string) => Promise<Document | null>;
    has: (entry: string) => Promise<boolean>;
    load: (hash: Record<string, string>) => ServerManifest;
    open: (file: string) => Promise<ServerManifest>;
    map: <T = unknown>(callback: DocumentIterator<T>) => T[];
    save: (file: string) => Promise<ServerManifest>;
    set: (entry: string) => Promise<Document>;
    toJSON: () => {
        [k: string]: string;
    };
    values: () => Document[];
    absolute: (entry: string) => Promise<string>;
    id: (entry: string) => Promise<string>;
    importPage: (entry: string) => Promise<import("./types.js").DocumentImport>;
    renderHMR: (entry: string) => Promise<string>;
    render: (entry: string, props?: UnknownNest) => Promise<string>;
};
export declare function build(options: Partial<BuildConfig>): {
    config: Readonly<{
        assetPath: string;
        basePath: string;
        clientPath: string;
        clientRoute: string;
        clientTemplate: string;
        cssFiles: string[] | undefined;
        cssRoute: string;
        cwd: string;
        documentTemplate: string;
        fs: import("@stackpress/lib/types").FileSystem | NodeFS;
        optimizeDeps: import("vite").DepOptimizationOptions | undefined;
        pagePath: string;
        pageTemplate: string;
        plugins: import("vite").PluginOption[];
        production: boolean;
        vite: import("vite").InlineConfig | undefined;
        watchIgnore: string[];
    }>;
    paths: Readonly<{
        asset: string;
        client: string;
        css?: string[];
        head?: string;
        page: string;
    }>;
    production: boolean;
    routes: Readonly<{
        client: string;
        css: string;
    }>;
    templates: Readonly<{
        client: string;
        document: string;
        page: string;
    }>;
    viteConfig: Readonly<import("vite").InlineConfig> | null;
    readonly size: number;
    builder: Builder;
    build: (config: ViteConfig) => Promise<import("rollup").RollupOutput | import("rollup").RollupOutput[] | import("rollup").RollupWatcher>;
    plugins: () => Promise<import("vite").PluginOption[]>;
    buildAllAssets: () => Promise<Partial<import("@stackpress/lib/types").ResponseStatus & {
        error: string;
        errors?: import("@stackpress/lib/types").NestedObject<string | string[]>;
        start?: number;
        end?: number;
        stack?: import("@stackpress/lib/types").Trace[];
    } & {
        results: {
            type: "page" | "client" | "asset";
            id: string;
            entry: string;
            contents: string | Uint8Array<ArrayBufferLike>;
            source?: string;
            destination: string;
        };
        total?: number;
    }>[]>;
    buildAllClients: () => Promise<Partial<import("@stackpress/lib/types").ResponseStatus & {
        error: string;
        errors?: import("@stackpress/lib/types").NestedObject<string | string[]>;
        start?: number;
        end?: number;
        stack?: import("@stackpress/lib/types").Trace[];
    } & {
        results: {
            type: "page" | "client" | "asset";
            id: string;
            entry: string;
            contents: string | Uint8Array<ArrayBufferLike>;
            source?: string;
            destination: string;
        };
        total?: number;
    }>[]>;
    buildAllPages: () => Promise<Partial<import("@stackpress/lib/types").ResponseStatus & {
        error: string;
        errors?: import("@stackpress/lib/types").NestedObject<string | string[]>;
        start?: number;
        end?: number;
        stack?: import("@stackpress/lib/types").Trace[];
    } & {
        results: {
            type: "page" | "client" | "asset";
            id: string;
            entry: string;
            contents: string | Uint8Array<ArrayBufferLike>;
            source?: string;
            destination: string;
        };
        total?: number;
    }>[]>;
    entries: () => [Document, number][];
    find: (id: string) => Document | null;
    forEach: (callback: DocumentIterator<unknown>) => void;
    get: (entry: string) => Promise<Document | null>;
    has: (entry: string) => Promise<boolean>;
    load: (hash: Record<string, string>) => ServerManifest;
    open: (file: string) => Promise<ServerManifest>;
    map: <T = unknown>(callback: DocumentIterator<T>) => T[];
    save: (file: string) => Promise<ServerManifest>;
    set: (entry: string) => Promise<Document>;
    toJSON: () => {
        [k: string]: string;
    };
    values: () => Document[];
    absolute: (entry: string) => Promise<string>;
    id: (entry: string) => Promise<string>;
    buildAssets: (entry: string) => Promise<[import("rollup").OutputChunk, ...(import("rollup").OutputAsset | import("rollup").OutputChunk)[]]>;
    buildClient: (entry: string) => Promise<[import("rollup").OutputChunk, ...(import("rollup").OutputAsset | import("rollup").OutputChunk)[]]>;
    buildPage: (entry: string, assets?: BuildResults) => Promise<[import("rollup").OutputChunk, ...(import("rollup").OutputAsset | import("rollup").OutputChunk)[]]>;
};
export declare function serve(options: Partial<ProductionConfig>): {
    config: Readonly<{
        assetPath: string;
        basePath: string;
        clientPath: string;
        clientRoute: string;
        clientTemplate: string;
        cssFiles: string[] | undefined;
        cssRoute: string;
        cwd: string;
        documentTemplate: string;
        fs: import("@stackpress/lib/types").FileSystem | NodeFS;
        optimizeDeps: import("vite").DepOptimizationOptions | undefined;
        pagePath: string;
        pageTemplate: string;
        plugins: import("vite").PluginOption[];
        production: boolean;
        vite: import("vite").InlineConfig | undefined;
        watchIgnore: string[];
    }>;
    paths: Readonly<{
        asset: string;
        client: string;
        css?: string[];
        head?: string;
        page: string;
    }>;
    routes: Readonly<{
        client: string;
        css: string;
    }>;
    templates: Readonly<{
        client: string;
        document: string;
        page: string;
    }>;
    server: Server;
    absolute: (entry: string) => Promise<string>;
    id: (entry: string) => Promise<string>;
    importPage: (entry: string) => Promise<import("./types.js").DocumentImport>;
    render: (entry: string, props?: UnknownNest) => Promise<string>;
};
export default function engine(options: Partial<ServerConfig>): {
    config: Readonly<{
        assetPath: string;
        basePath: string;
        clientPath: string;
        clientRoute: string;
        clientTemplate: string;
        cssFiles: string[] | undefined;
        cssRoute: string;
        cwd: string;
        documentTemplate: string;
        fs: import("@stackpress/lib/types").FileSystem | NodeFS;
        optimizeDeps: import("vite").DepOptimizationOptions | undefined;
        pagePath: string;
        pageTemplate: string;
        plugins: import("vite").PluginOption[];
        production: boolean;
        vite: import("vite").InlineConfig | undefined;
        watchIgnore: string[];
    }>;
    paths: Readonly<{
        asset: string;
        client: string;
        css?: string[];
        head?: string;
        page: string;
    }>;
    production: boolean;
    routes: Readonly<{
        client: string;
        css: string;
    }>;
    templates: Readonly<{
        client: string;
        document: string;
        page: string;
    }>;
    viteConfig: Readonly<import("vite").InlineConfig> | null;
    readonly size: number;
    builder: Builder;
    build: (config: ViteConfig) => Promise<import("rollup").RollupOutput | import("rollup").RollupOutput[] | import("rollup").RollupWatcher>;
    dev: () => Promise<import("vite").ViteDevServer>;
    http: (req: IM, res: SR) => Promise<unknown>;
    middlewares: () => Promise<import("vite").Connect.Server>;
    plugins: () => Promise<import("vite").PluginOption[]>;
    fetch: <T = any>(url: string) => Promise<T>;
    import: <T = any>(pathname: string, extnames?: string[]) => Promise<T>;
    resolve: (pathname: string, extnames?: string[]) => Promise<{
        filepath: string;
        basepath: string;
        extname: string;
    }>;
    buildAllAssets: () => Promise<Partial<import("@stackpress/lib/types").ResponseStatus & {
        error: string;
        errors?: import("@stackpress/lib/types").NestedObject<string | string[]>;
        start?: number;
        end?: number;
        stack?: import("@stackpress/lib/types").Trace[];
    } & {
        results: {
            type: "page" | "client" | "asset";
            id: string;
            entry: string;
            contents: string | Uint8Array<ArrayBufferLike>;
            source?: string;
            destination: string;
        };
        total?: number;
    }>[]>;
    buildAllClients: () => Promise<Partial<import("@stackpress/lib/types").ResponseStatus & {
        error: string;
        errors?: import("@stackpress/lib/types").NestedObject<string | string[]>;
        start?: number;
        end?: number;
        stack?: import("@stackpress/lib/types").Trace[];
    } & {
        results: {
            type: "page" | "client" | "asset";
            id: string;
            entry: string;
            contents: string | Uint8Array<ArrayBufferLike>;
            source?: string;
            destination: string;
        };
        total?: number;
    }>[]>;
    buildAllPages: () => Promise<Partial<import("@stackpress/lib/types").ResponseStatus & {
        error: string;
        errors?: import("@stackpress/lib/types").NestedObject<string | string[]>;
        start?: number;
        end?: number;
        stack?: import("@stackpress/lib/types").Trace[];
    } & {
        results: {
            type: "page" | "client" | "asset";
            id: string;
            entry: string;
            contents: string | Uint8Array<ArrayBufferLike>;
            source?: string;
            destination: string;
        };
        total?: number;
    }>[]>;
    entries: () => [Document, number][];
    find: (id: string) => Document | null;
    forEach: (callback: DocumentIterator<unknown>) => void;
    get: (entry: string) => Promise<Document | null>;
    has: (entry: string) => Promise<boolean>;
    load: (hash: Record<string, string>) => ServerManifest;
    open: (file: string) => Promise<ServerManifest>;
    map: <T = unknown>(callback: DocumentIterator<T>) => T[];
    save: (file: string) => Promise<ServerManifest>;
    set: (entry: string) => Promise<Document>;
    toJSON: () => {
        [k: string]: string;
    };
    values: () => Document[];
    absolute: (entry: string) => Promise<string>;
    id: (entry: string) => Promise<string>;
    importPage: (entry: string) => Promise<import("./types.js").DocumentImport>;
    relative: (entry: string, fromFile: string) => Promise<string>;
    buildAssets: (entry: string) => Promise<[import("rollup").OutputChunk, ...(import("rollup").OutputAsset | import("rollup").OutputChunk)[]]>;
    buildClient: (entry: string) => Promise<[import("rollup").OutputChunk, ...(import("rollup").OutputAsset | import("rollup").OutputChunk)[]]>;
    buildPage: (entry: string, assets?: BuildResults) => Promise<[import("rollup").OutputChunk, ...(import("rollup").OutputAsset | import("rollup").OutputChunk)[]]>;
    renderHMR: (entry: string) => Promise<string>;
    render: (entry: string, props?: UnknownNest) => Promise<string>;
};
