import path from 'node:path';
export default class DocumentBuilder {
    _document;
    _server;
    constructor(document) {
        this._document = document;
        this._server = document.server;
    }
    async buildAssets() {
        const { resource, templates } = this._server;
        const pageScript = templates.page;
        const code = pageScript.replace('{styles}', '[]');
        const url = await this._renderVFS('assets', code);
        const config = await this._getAssetBuildOptions(url);
        const results = await resource.build(config);
        return results.output;
    }
    async buildClient() {
        const { resource, templates } = this._server;
        const template = templates.client;
        const url = await this._renderVFS('client', template);
        const config = await this._getClientBuildOptions(url);
        const results = await resource.build(config);
        return results.output;
    }
    async buildPage(assets) {
        const { resource, templates } = this._server;
        assets = assets || await this.buildAssets();
        const styles = assets
            .filter(asset => asset.type === 'asset')
            .filter(asset => asset.fileName.startsWith('assets/'))
            .filter(asset => path.extname(asset.fileName) === '.css')
            .map(asset => asset.fileName.substring(7));
        const pageScript = templates.page;
        const code = pageScript.replace('{styles}', JSON.stringify(styles));
        const url = await this._renderVFS('page', code);
        const config = await this._getPageBuildOptions(url);
        const results = await resource.build(config);
        return results.output;
    }
    async _getAssetBuildOptions(url) {
        const { loader } = this._server;
        return {
            configFile: false,
            root: loader.cwd,
            build: {
                write: false,
                rollupOptions: {
                    input: url,
                    output: {
                        format: 'es',
                        entryFileNames: '[name].js',
                    }
                }
            }
        };
    }
    async _getClientBuildOptions(url) {
        const { loader } = this._server;
        return {
            configFile: false,
            root: loader.cwd,
            build: {
                write: false,
                rollupOptions: {
                    input: url,
                    output: {
                        format: 'es',
                        entryFileNames: '[name].js',
                    }
                }
            }
        };
    }
    async _getPageBuildOptions(url) {
        const { loader } = this._server;
        return {
            configFile: false,
            root: loader.cwd,
            build: {
                write: false,
                rollupOptions: {
                    preserveEntrySignatures: 'exports-only',
                    input: url,
                    external: ['react', 'react-dom', 'react/jsx-runtime'],
                    output: {
                        format: 'es',
                        entryFileNames: '[name].js',
                        exports: 'named',
                        globals: {
                            react: 'React',
                            'react-dom': 'ReactDOM',
                            'react/jsx-runtime': 'jsxRuntime'
                        }
                    }
                }
            }
        };
    }
    async _renderVFS(name, template) {
        const { vfs } = this._server;
        const { loader } = this._document;
        const absolute = await loader.absolute();
        const file = `${absolute}.${name}.tsx`;
        const relative = await loader.relative(file);
        const code = template.replaceAll('{entry}', relative);
        return vfs.set(file, code);
    }
}
