import path from 'node:path';
import { VFS_PROTOCOL } from './constants.js';
export function css(cssFiles) {
    return {
        name: 'reactus-inject-css',
        enforce: 'pre',
        transform(code, id) {
            if (id.endsWith('.tsx')) {
                const imports = cssFiles.map(css => `import '${css}';`);
                return imports.join('\n') + '\n' + code;
            }
            return code;
        },
    };
}
export function file(loader, extnames = ['.js', '.ts', '.tsx']) {
    const cache = new Map();
    return {
        name: 'reactus-file-loader',
        async resolveId(source, importer) {
            if (source.startsWith('/'))
                return;
            if (cache.has(source))
                return cache.get(source);
            let pwd = loader.cwd;
            if (importer) {
                if (importer.startsWith('imfs:')) {
                    importer = importer.substring(5).split(';')[2];
                }
                pwd = path.dirname(importer);
            }
            const filepath = await loader.resolveFile(source, extnames, pwd);
            if (filepath) {
                cache.set(source, filepath);
                return filepath;
            }
        }
    };
}
export function hmr(server) {
    const { routes, manifest } = server;
    return async (req, res, next) => {
        if (!req.url
            || !req.url.startsWith(routes.client)
            || !req.url.endsWith('.tsx')
            || res.headersSent) {
            next();
            return;
        }
        const id = req.url.slice(routes.client.length + 1, -4);
        const document = manifest.find(id);
        if (document) {
            const client = await document.render.renderHMRClient();
            if (client) {
                res.setHeader('Content-Type', 'text/javascript');
                res.end(client);
                return;
            }
        }
        next();
    };
}
export function vfs(vfs) {
    return {
        name: 'reactus-virtual-loader',
        configureServer(server) {
            server.watcher.on('change', filePath => {
                if (filePath.startsWith(VFS_PROTOCOL)) {
                    const { ws, moduleGraph: graph } = server;
                    const mod = graph.getModuleById(filePath);
                    if (mod) {
                        graph.invalidateModule(mod);
                        ws.send({ type: 'full-reload', path: '*' });
                    }
                }
            });
        },
        resolveId(source, importer) {
            if (source.startsWith(VFS_PROTOCOL)) {
                return source;
            }
            else if (source.includes(VFS_PROTOCOL)) {
                return source.substring(source.indexOf(VFS_PROTOCOL));
            }
            else if (importer?.startsWith(VFS_PROTOCOL)
                && (source.startsWith('./') || source.startsWith('../'))) {
                const file = importer.substring(VFS_PROTOCOL.length);
                const resolved = path.resolve(path.dirname(file), source);
                return !path.extname(resolved)
                    ? resolved + path.extname(file)
                    : resolved;
            }
        },
        load(id) {
            if (id.startsWith(VFS_PROTOCOL)) {
                const file = id.substring(VFS_PROTOCOL.length);
                if (vfs.has(file)) {
                    const contents = vfs.get(file);
                    if (typeof contents === 'string') {
                        return contents;
                    }
                }
                return null;
            }
        }
    };
}
